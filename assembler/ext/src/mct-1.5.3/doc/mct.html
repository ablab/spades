<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.8.1: http://docutils.sourceforge.net/" />
<title>Miscellaneous Container Templates</title>
<meta name="author" content="Paul Pogonyshev" />
<meta name="copyright" content="© 2009, 2010, 2011, 2012 Paul Pogonyshev" />
<style type="text/css">

body
{
    margin-left: 1.5em;
    margin-right: 1.5em;
}

div.document
{
    width: 90ex;
}

h1.title
{
    margin-bottom: 1.5em;
    font-weight: bold;
    font-size: 180%;
    text-align: center;
}

div.section h1
{
    margin-top: 2.2em;
    border-bottom: 1px solid #ccc;
    font-weight: bold;
    font-size: 150%;
    text-align: left;
}

div.section h2
{
    margin-top: 2.0em;
    font-weight: bold;
    font-size: 130%;
    text-align: left;
}

div.section h3
{
    margin-top: 1.8em;
    font-weight: bold;
    font-size: 115%;
    text-align: left;
}

div.section h4
{
    margin-top: 1.7em;
    font-weight: bold;
    font-size: 105%;
    text-align: left;
}


div.section div.section div.section div.section
{
    padding-left: 3em;
}

div.section div.section div.section div.section h4
{
    margin-left: -1.5em;
}


a
{
    color: #539bc0;
    text-decoration: underline;
}

a:visited
{
    color: #3b6e88;
    text-decoration: underline;
}

a:hover
{
    color: #65bdea;
    text-decoration: underline;
}

div.topic
{
    margin: 1.5em 2em;
}

p.topic-title
{
    font-weight: bold;
    font-size: 110%;
    text-align: left;
    margin: 0 0 0.5em 0;
}

div.topic ul
{
    list-style-type: none;
    margin: 0 0 0 0;
    padding: 0 0 0 1.5em;
}

div.topic ul ul
{
    padding-left: 1.5em;
}

div.contents > ul > li
{
    padding-bottom: 0.4em;
}

div.contents > ul > li > a
{
    font-weight: bold;
}

div.topic a, div.topic a:visited
{
    text-decoration: none;
}

div.topic a:hover
{
    text-decoration: underline;
}

div.local
{
    font-size: 85%;
}

a.toc-backref
{
    text-decoration: none;
}

a.toc-backref:hover
{
    color: #65bdea;
    text-decoration: underline;
}

th.docinfo-name
{
    padding-right: 1em;
    text-align: left;
}

th.field-name
{
    padding-right: 1em;
    text-align: left;
}

th.field-name tt
{
    font-weight: normal;
}

pre.literal-block
{
    margin-left: 3em;
    margin-right: 3em;
    font-family: monospace;
    font-size: 90%;
    text-align: left;
}

div.warning
{
    margin-left: 0.3em;
    border-left: 2px solid #a00;
    padding-left: 0.5em;
}

p.admonition-title
{
    font-weight: bold;
}

div.admonition-special-note
{
    margin-left: 2em;
    margin-right: 2em;
}

div.admonition-compiler-specific
{
    margin: 1em 0 0 3em;
    border-left: 1px dashed #666;
    padding-left: 0.5em;
}

div.admonition-compiler-specific p.admonition-title
{
    display: none;
    speak: none;
}

div.admonition-versioned
{
    float: right;
    margin: 0 0 1em 2em;
    border-bottom: 1px dashed #666;
    padding: 0 0.5em 0.1em 0.5em;
    color: #666;
}

div.admonition-versioned p
{
    margin: 0;
}

div.admonition-versioned p.admonition-title
{
    display: none;
    speak: none;
}

div.admonition-deprecated
{
    margin-left: 3em;
    border-left: 1px dotted #ccc;
    padding-left: 0.5em;
    font-size: 95%;
    color: #333;
}

div.admonition-deprecation-description
{
    border-left: 2px solid #a00;
    padding-left: 0.5em;
    font-size: 105%;
}

div.admonition-deprecated p.admonition-title, div.admonition-deprecation-description p.admonition-title
{
    display: none;
    speak: none;
}

ul.simple > li
{
    padding-bottom: 0.5em;
}

</style>
</head>
<body>
<div class="document" id="miscellaneous-container-templates">
<h1 class="title">Miscellaneous Container Templates</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Paul Pogonyshev</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference external" href="mailto:pogonyshev&#64;gmx.net">pogonyshev&#64;gmx.net</a></td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>1.6</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>© 2009, 2010, 2011, 2012 Paul Pogonyshev</td></tr>
</tbody>
</table>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id313">Overview</a><ul>
<li><a class="reference internal" href="#design-goals-and-guarantees" id="id314">Design Goals and Guarantees</a></li>
<li><a class="reference internal" href="#closed-hash-set-and-closed-hash-map" id="id315"><tt class="docutils literal">closed_hash_set</tt> and <tt class="docutils literal">closed_hash_map</tt></a></li>
<li><a class="reference internal" href="#linked-hash-set-and-linked-hash-map" id="id316"><tt class="docutils literal">linked_hash_set</tt> and <tt class="docutils literal">linked_hash_map</tt></a></li>
<li><a class="reference internal" href="#forward-hash-set-and-forward-hash-map" id="id317"><tt class="docutils literal">forward_hash_set</tt> and <tt class="docutils literal">forward_hash_map</tt></a></li>
<li><a class="reference internal" href="#optional-intrusiveness" id="id318">Optional Intrusiveness</a></li>
<li><a class="reference internal" href="#optional-boost-serialization-support" id="id319">Optional Boost.Serialization Support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inclusion-time-configuration" id="id320">Inclusion-Time Configuration</a><ul>
<li><a class="reference internal" href="#library-support-including-stdlib" id="id321">Library Support, Including Stdlib</a></li>
<li><a class="reference internal" href="#compiler-capabilities" id="id322">Compiler Capabilities</a></li>
<li><a class="reference internal" href="#debugging-support-for-mct-containers" id="id323">Debugging Support for MCT Containers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-notes-and-terminology" id="id324">Common Notes and Terminology</a></li>
<li><a class="reference internal" href="#differences-with-tr1-containers" id="id325">Differences With TR1 Containers</a><ul>
<li><a class="reference internal" href="#conceptual-differences" id="id326">Conceptual Differences</a></li>
<li><a class="reference internal" href="#mct-limitations" id="id327">MCT Limitations</a></li>
<li><a class="reference internal" href="#unique-to-mct" id="id328">Unique to MCT</a></li>
</ul>
</li>
<li><a class="reference internal" href="#recipes" id="id329">Recipes</a><ul>
<li><a class="reference internal" href="#choosing-the-best-hash-table" id="id330">Choosing the Best Hash Table</a></li>
<li><a class="reference internal" href="#implementing-a-cache-of-limited-size" id="id331">Implementing a Cache of Limited Size</a></li>
<li><a class="reference internal" href="#implementing-queue-or-stack-with-lookup" id="id332">Implementing Queue or Stack With Lookup</a></li>
<li><a class="reference internal" href="#improving-performance-of-containers-at-no-storage-cost" id="id333">Improving Performance of Containers at No Storage Cost</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance-tips" id="id334">Performance Tips</a></li>
<li><a class="reference internal" href="#reference" id="id335">Reference</a><ul>
<li><a class="reference internal" href="#closed-hash-set" id="id336"><tt class="docutils literal">closed_hash_set</tt></a></li>
<li><a class="reference internal" href="#closed-hash-map" id="id337"><tt class="docutils literal">closed_hash_map</tt></a></li>
<li><a class="reference internal" href="#linked-hash-set" id="id338"><tt class="docutils literal">linked_hash_set</tt></a></li>
<li><a class="reference internal" href="#linked-hash-map" id="id339"><tt class="docutils literal">linked_hash_map</tt></a></li>
<li><a class="reference internal" href="#forward-hash-set" id="id340"><tt class="docutils literal">forward_hash_set</tt></a></li>
<li><a class="reference internal" href="#forward-hash-map" id="id341"><tt class="docutils literal">forward_hash_map</tt></a></li>
<li><a class="reference internal" href="#huge-linked-hash-and-huge-forward-hash" id="id342"><tt class="docutils literal">huge_linked_hash_*</tt> and <tt class="docutils literal">huge_forward_hash_*</tt></a></li>
<li><a class="reference internal" href="#cross-container-functions" id="id343">Cross-Container Functions</a></li>
<li><a class="reference internal" href="#common-debugging-members" id="id344">Common Debugging Members</a></li>
<li><a class="reference internal" href="#type-properties" id="id345">Type Properties</a></li>
<li><a class="reference internal" href="#external-use-specification" id="id346">External Use Specification</a></li>
<li><a class="reference internal" href="#automated-debugging" id="id347">Automated Debugging</a></li>
<li><a class="reference internal" href="#preprocessor-symbols" id="id348">Preprocessor Symbols</a></li>
<li><a class="reference internal" href="#full-list-of-headers" id="id349">Full List of Headers</a></li>
<li><a class="reference internal" href="#api-changes" id="id350">API Changes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#documentation-copyright-and-permissions-notice" id="id351">Documentation Copyright and Permissions Notice</a></li>
</ul>
</div>
<div class="section" id="overview">
<h1><a class="toc-backref" href="#id313">Overview</a></h1>
<p>Miscellaneous Container Templates (MCT for short) is an assorted collection of containers
designed similarly to those provided by the standard library.  Currently, there are six
<a class="footnote-reference" href="#id2" id="id1">[1]</a> closely related hash table containers: <tt class="docutils literal">closed_hash_set</tt>, <tt class="docutils literal">closed_hash_map</tt>,
<tt class="docutils literal">linked_hash_set</tt>, <tt class="docutils literal">linked_hash_map</tt>, <tt class="docutils literal">forward_hash_set</tt> and <tt class="docutils literal">forward_hash_map</tt>.</p>
<p>The first two are very similar in behavior to TR1 (or Boost) <tt class="docutils literal">unordered_set</tt> and
<tt class="docutils literal">unordered_map</tt>.  Unlike those, however, they use <a class="reference external" href="http://en.wikipedia.org/wiki/Closed_hashing">closed hashing scheme</a> (also known
as <em>open addressing</em>).  As a result, they tend to be considerably faster in many cases.</p>
<p>Linked ones have a stable iteration order and some additional functions to change that.
However, they use more memory and are slower than “simple” closed hash tables, so should
be used only when specific iteration order is really needed.</p>
<p>Finally, forward hash tables are more efficient than linked ones, but support less
operations and generally have cumbersome interface.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>There are also “huge” containers for linked and forward sets and maps, but those
can be seen as simply variants of the normal ones.</td></tr>
</tbody>
</table>
<div class="section" id="design-goals-and-guarantees">
<h2><a class="toc-backref" href="#id314">Design Goals and Guarantees</a></h2>
<p>Containers in the library are written to meet a set of goals and provide certain
guarantees regardless of behavior of contained elements.</p>
<p><strong>Standard library and TR1 compatibility</strong></p>
<blockquote>
Where possible, MCT is compatible with the standard library and TR1.  MCT classes can
usually be used as drop-in replacement for similar standard library or Boost
containers.</blockquote>
<p><strong>Thread safety</strong></p>
<blockquote>
MCT classes are thread-safe in the face of proper synchronization.  Non-mutating
(const) functions are always safe, i.e. there is no internal state which would require
synchronization.  Mutating (non-const) functions require that only one thread has
access to the modified container; other threads must not “touch” the container while
modifications takes place, not even read from it.</blockquote>
<p><strong>Exception safety</strong></p>
<blockquote>
Whenever client code throws an exception, containers are always left in a consistent
state and there are no memory leaks.  This is often referred to as <em>basic exception
safety</em>.  When possible, MCT also provides <em>strong exception safety</em>.  In other words,
if an exception is thrown during an operation, it is cancelled and container’s state
is exactly the same as if operation never happened.</blockquote>
<p><strong>Full allocator support</strong></p>
<blockquote>
MCT containers provide good support for any conforming allocator type, including
allocators that use non-standard pointers.  The latter, in particular, is important
for sharing containers between processes using Boost.Interprocess.</blockquote>
<p><strong>Eased debugging</strong></p>
<blockquote>
Containers come with several debugging functions that allow to find where they become
broken (e.g. by using an invalid iterator), which hash function is better and similar
things.</blockquote>
<p>Additionally, if permitted by functionality provided by certain container type, the
following is also provided by implementation.</p>
<p><strong>High speed</strong></p>
<blockquote>
MCT classes are optimized for speed provided that other goals are met.</blockquote>
<p><strong>Rare memory allocations</strong></p>
<blockquote>
Memory allocation can be a performance bottleneck of CPU-intensive programs.  This is
especially true for multithreaded programs as (currently) memory allocation requires
synchronization.  Such problems can be alleviated by specially tailored allocators,
but MCT classes don’t allocate memory often anyway.</blockquote>
<p>In particular, <tt class="docutils literal">closed_hash_*</tt> containers are fast and don’t allocate memory often.  In
comparison, their <tt class="docutils literal">linked_hash_*</tt> and <tt class="docutils literal">forward_hash_*</tt> counterparts are not so fast,
but this is dictated by the additional provided features.</p>
</div>
<div class="section" id="closed-hash-set-and-closed-hash-map">
<h2><a class="toc-backref" href="#id315"><tt class="docutils literal">closed_hash_set</tt> and <tt class="docutils literal">closed_hash_map</tt></a></h2>
<p>Fast general-purpose hash table containers.  The only important functional difference from
TR1 <tt class="docutils literal">unordered_set</tt> and <tt class="docutils literal">unordered_map</tt> is invalidation of references and pointers to
elements.</p>
<p>The following subsections provide a more in-depth comparison.  Also refer to <a class="reference internal" href="#differences-with-tr1-containers">Differences
With TR1 Containers</a> section.</p>
<div class="section" id="brief-comparison-with-tr1-or-boost-containers">
<h3>Brief Comparison With TR1 (or Boost) Containers</h3>
<p>Advantages of MCT classes:</p>
<ul class="simple">
<li>significantly faster for sufficiently small elements;</li>
<li>do not allocate memory often.</li>
</ul>
<p>Disadvantages:</p>
<ul class="simple">
<li>can move data in memory, i.e. invalidate pointers and references;</li>
<li>can become slow if elements have expensive copy constructors, unless special care is
taken to avoid rehashing;</li>
<li>usually use more memory, especially with large-sized values.</li>
</ul>
</div>
<div class="section" id="brief-comparison-with-google-sparsehash-library">
<h3>Brief Comparison With Google Sparsehash Library</h3>
<p>Advantages of MCT classes:</p>
<ul class="simple">
<li>no restriction on contained values/keys;</li>
<li>exception safety;</li>
<li>support for C++0x features;</li>
<li>optional intrusiveness gives better performance for certain types.</li>
</ul>
<p>Disadvantages:</p>
<ul class="simple">
<li>MCT seems to be somewhat slower on average <a class="footnote-reference" href="#id4" id="id3">[2]</a>;</li>
<li>no analogue for <tt class="docutils literal">sparse_hash_*</tt> containers.</li>
</ul>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>Results vary with different benchmarks, compilers and CPU architectures.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="linked-hash-set-and-linked-hash-map">
<h2><a class="toc-backref" href="#id316"><tt class="docutils literal">linked_hash_set</tt> and <tt class="docutils literal">linked_hash_map</tt></a></h2>
<p>Containers similar to their <tt class="docutils literal">closed_hash_*</tt> counterparts, but with stable iteration
order (i.e. one which doesn’t change unpredictably).  This is achieved by internally
keeping a doubly-linked lists consisting of all the elements.</p>
<p>In the unlikely case you ever need <em>over 1 billion</em> buckets, read about <a class="reference internal" href="#huge-linked-hash-tables">huge linked hash
tables</a> in the reference.</p>
<div class="section" id="brief-comparison-with-closed-hash-set-and-closed-hash-map">
<h3>Brief Comparison With <tt class="docutils literal">closed_hash_set</tt> and <tt class="docutils literal">closed_hash_map</tt></h3>
<p>Advantages:</p>
<ul class="simple">
<li>stable and predictable iteration order;</li>
<li>strictly constant complexity of decrement and increment operators on iterators (for
<tt class="docutils literal">closed_hash_*</tt> tables see reference);</li>
<li>a few functions to change iteration order;</li>
<li><tt class="docutils literal">reverse_iterator</tt> and related members;</li>
<li>range insertion provides strong exception safety.</li>
</ul>
<p>Disadvantages (all qualitative):</p>
<ul class="simple">
<li>slower;</li>
<li>use more memory, which is especially noticeable with small elements.</li>
</ul>
</div>
</div>
<div class="section" id="forward-hash-set-and-forward-hash-map">
<h2><a class="toc-backref" href="#id317"><tt class="docutils literal">forward_hash_set</tt> and <tt class="docutils literal">forward_hash_map</tt></a></h2>
<p>These containers are somewhat similar to linked hash tables described in the previous
section.  However, the internally kept list spanning all the elements is only
singly-linked.  Thus, forward hash tables use less memory and are a little faster, but, on
the downside, cannot support considerable part of <tt class="docutils literal">linked_hash_*</tt> functionality.</p>
<p>These containers are inspired by <tt class="docutils literal">forward_list</tt> in C++0x standard library.</p>
<p>In the unlikely case you ever need <em>over 1 billion</em> buckets, read about <a class="reference internal" href="#huge-forward-hash-tables">huge forward hash
tables</a> in the reference.</p>
<div class="section" id="brief-comparison-with-linked-hash-set-and-linked-hash-map">
<h3>Brief Comparison With <tt class="docutils literal">linked_hash_set</tt> and <tt class="docutils literal">linked_hash_map</tt></h3>
<p>Advantages (all qualitative):</p>
<ul class="simple">
<li>faster;</li>
<li>use less memory, which is especially noticeable with small elements.</li>
</ul>
<p>Disadvantages (all functional):</p>
<ul class="simple">
<li><em>no</em> erase-by-key member;</li>
<li>cumbersome interface with several important functions replaced by <tt class="docutils literal">*_after()</tt>
variants;</li>
<li>iterators are forward, not bidirectional; accordingly, no <tt class="docutils literal">reverse_iterator</tt>;</li>
<li>range insertion provides only basic exception safety.</li>
</ul>
</div>
</div>
<div class="section" id="optional-intrusiveness">
<h2><a class="toc-backref" href="#id318">Optional Intrusiveness</a></h2>
<p>MCT lets you to specify mode of <em>external use</em> of a type.  This information is completely
optional and, in fact, cannot be specified for many types: only those with “holes” in
their layout can afford to dedicate a byte or more for external use.  However, when
specified, it will be leveraged by <tt class="docutils literal">closed_hash_set</tt> and <tt class="docutils literal">closed_hash_map</tt> containers
to switch to an (even more) efficient implementation.</p>
</div>
<div class="section" id="optional-boost-serialization-support">
<h2><a class="toc-backref" href="#id319">Optional Boost.Serialization Support</a></h2>
<p>All MCT containers can be serialized with Boost Serialization library.  This is optional
in the sense you don’t have to have Boost.Serialization installed in order to use MCT.</p>
<p>But if you do want to define serialization support functions, include headers
<tt class="docutils literal"><span class="pre">&lt;mct/hash-set-serialization.hpp&gt;</span></tt> and/or <tt class="docutils literal"><span class="pre">&lt;mct/hash-map-serialization.hpp&gt;</span></tt>, as
needed.  If Boost.Serialization is not installed, inclusion of either of this header will
lead to compilation errors.</p>
</div>
</div>
<div class="section" id="inclusion-time-configuration">
<h1><a class="toc-backref" href="#id320">Inclusion-Time Configuration</a></h1>
<p>MCT can be configured both at installation time and at inclusion time.  In other words,
regardless of which parameters were chosen during installation, you can still influence
how MCT behaves in your program by defining certain symbols before including its headers.</p>
<p>A reason to configure MCT at inclusion time is to avoid dependencies to what is determined
during installation.  For example, the library might be installed with disabled C++0x
support; if you compile your program using C++0x compiler, define <tt class="docutils literal">MCT_CXX0X_SUPPORTED</tt>
to a non-zero value.  Another reason is to request debugging assistance from the library.</p>
<p>Of course, all configuration parameters below are optional.</p>
<div class="section" id="library-support-including-stdlib">
<h2><a class="toc-backref" href="#id321">Library Support, Including Stdlib</a></h2>
<div class="section" id="mct-hash-header-and-mct-hash-namespace">
<h3><tt class="docutils literal">MCT_HASH_HEADER</tt> and <tt class="docutils literal">MCT_HASH_NAMESPACE</tt></h3>
<p>Hash functions are not yet part of C++ standard and are only defined in TR1.  To make MCT
less dependent on C++ compiler and standard library features, these configuration settings
can be overriden at inclusion time.  If they are not defined, values determined at MCT
installation take effect.</p>
<p>Common values are, for C++0x compilers:</p>
<pre class="literal-block">
#define MCT_HASH_HEADER     &lt;functional&gt;
#define MCT_HASH_NAMESPACE  std
</pre>
<p>For Boost:</p>
<pre class="literal-block">
#define MCT_HASH_HEADER     &lt;boost/functional/hash.hpp&gt;
#define MCT_HASH_NAMESPACE  boost
</pre>
<p>For standard library implementation with additional TR1 part:</p>
<pre class="literal-block">
#define MCT_HASH_HEADER     &lt;tr1/functional&gt;
#define MCT_HASH_NAMESPACE  std::tr1
</pre>
<p>It is not required to use these values.  If you use a different (but compatible)
implementation of hash function, you can define the settings accordingly.</p>
</div>
<div class="section" id="mct-type-traits-header-and-mct-type-traits-namespace">
<h3><tt class="docutils literal">MCT_TYPE_TRAITS_HEADER</tt> and <tt class="docutils literal">MCT_TYPE_TRAITS_NAMESPACE</tt></h3>
<p>These are very similar to above symbols for the hash function implementation.  Unlike hash
functions, type traits are not required for MCT to work, so MCT can be installed even if
no provider is found <a class="footnote-reference" href="#id6" id="id5">[3]</a>.  If they are not present, however, several functions in MCT
classes will be considerably slower.</p>
<p>There are probably few cases when default configuration is not good enough.  Still, you
can override it at inclusion time; e.g. for C++0x compilers:</p>
<pre class="literal-block">
#define MCT_TYPE_TRAITS_HEADER     &lt;type_traits&gt;
#define MCT_TYPE_TRAITS_NAMESPACE  std
</pre>
<p>For Boost:</p>
<pre class="literal-block">
#define MCT_TYPE_TRAITS_HEADER     &lt;boost/type_traits.hpp&gt;
#define MCT_TYPE_TRAITS_NAMESPACE  boost
</pre>
<p>For standard library implementation with additional TR1 part:</p>
<pre class="literal-block">
#define MCT_TYPE_TRAITS_HEADER     &lt;tr1/type_traits&gt;
#define MCT_TYPE_TRAITS_NAMESPACE  std::tr1
</pre>
<p>Like with hash function symbols, you can as well use different values.</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>This is pretty unlikely since one should just come along with hash provider.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="compiler-capabilities">
<h2><a class="toc-backref" href="#id322">Compiler Capabilities</a></h2>
<div class="section" id="mct-cxx0x-supported">
<h3><tt class="docutils literal">MCT_CXX0X_SUPPORTED</tt></h3>
<p>If defined to a non-zero value, all containers will support various C++0x features.
Currently these are:</p>
<ul class="simple">
<li>initializer list constructor and assignment operator;</li>
<li>move constructor and assignment operator that don’t copy buckets (i.e. are O(1) in
complexity);</li>
<li>using move constructor when inserting elements by rvalue-reference;</li>
<li><tt class="docutils literal">emplace()</tt> and similar functions (not more efficient than <tt class="docutils literal">insert()</tt>, provided only
for compatibility).</li>
</ul>
</div>
<div class="section" id="mct-have-long-long">
<h3><tt class="docutils literal">MCT_HAVE_LONG_LONG</tt></h3>
<p>If defined to a non-zero value, compiler supports <tt class="docutils literal">long long</tt> type.  This information
can be used by MCT for optimizations.</p>
</div>
</div>
<div class="section" id="debugging-support-for-mct-containers">
<h2><a class="toc-backref" href="#id323">Debugging Support for MCT Containers</a></h2>
<div class="section" id="mct-enable-debugging">
<h3><tt class="docutils literal">MCT_ENABLE_DEBUGGING</tt></h3>
<p>If this flag is defined to any non-zero value, all containers will have additional
debugging members: <tt class="docutils literal">valid_iterator()</tt>, <tt class="docutils literal">valid_iterator_range()</tt>, <tt class="docutils literal">used_memory()</tt>,
<tt class="docutils literal">validate_integrity()</tt> and <tt class="docutils literal">collect_statistics()</tt>.  See <a class="reference internal" href="#common-debugging-members">Common Debugging Members</a>
reference section for more information.</p>
</div>
<div class="section" id="mct-check-preconditions">
<h3><tt class="docutils literal">MCT_CHECK_PRECONDITIONS</tt></h3>
<p>When set to a non-zero value, functions in MCT will test preconditions and throw
unspecified subclass of <tt class="docutils literal"><span class="pre">std::logic_error</span></tt> if they are not met.  This is moderately
slow, but will detect programming bugs like using an invalidated iterator or popping from
an empty <tt class="docutils literal">linked_hash_map</tt>.  See <a class="reference internal" href="#automated-debugging">Automated Debugging</a> reference section for more
information.</p>
</div>
<div class="section" id="mct-self-validation">
<h3><tt class="docutils literal">MCT_SELF_VALIDATION</tt></h3>
<p>Any non-zero value will cause MCT containers to validate internal integrity <em>after each
modification</em>.  This is <strong>extremely slow</strong>, so use only for debugging actual problems.
See <a class="reference internal" href="#automated-debugging">Automated Debugging</a> reference section for more details.</p>
</div>
</div>
</div>
<div class="section" id="common-notes-and-terminology">
<h1><a class="toc-backref" href="#id324">Common Notes and Terminology</a></h1>
<p>Elements</p>
<blockquote>
Following common standard library requirement, MCT requires that element’s destructor
doesn’t throw.  Behavior with a throwing element destructor is undefined.</blockquote>
<p id="common-note-above">Hash function and equality predicate</p>
<blockquote>
MCT classes currently require that copy constructors of these function objects do not
throw (but <em>calling</em> the object may throw, which is more important).  This restriction
may be lifted in a future MCT version.</blockquote>
<p id="flag-description-above"><tt class="docutils literal">keep_hashes</tt></p>
<blockquote>
All container have a <tt class="docutils literal">keep_hashes</tt> template parameter which defaults to <tt class="docutils literal">false</tt>.
When it is <tt class="docutils literal">true</tt>, container will store hash values for its elements.  Elements with
different hash values are never compared against each other, which will often give a
speedup if comparator is relatively slow.</blockquote>
<p>Bucket count</p>
<blockquote>
Number of buckets as specified as parameter to constructors or <tt class="docutils literal">rehash()</tt> function
is always advisory, not mandatory.  For instance, current implementation always uses
number of buckets that is a power of 2.</blockquote>
<p>Load factor</p>
<blockquote>
<p>Load factor of a hash container is ratio of its size to number of buckets.  Each
container has maximum allowed load factor and if actual load factor exceeds this
value, container is rehashed, usually doubling number of buckets.  The smaller the
maximum load factor is, the faster (on average) the container will be.  At the same
time, it will also use more memory.</p>
<p>Because each bucket in closed hashing scheme can contain at most one element, load
factor of containers in this library never exceeds 1.</p>
</blockquote>
<p>Function complexity</p>
<blockquote>
<p>When describing complexity, this manual often uses words ‘expected’ and ‘amortized’.
The first refers to the common case.  E.g. in a hash table many operations have
constant complexity <em>if</em> the hash function is good enough and elements are not
especially chosen for bad performance.  (Even good hash functions have weak spots and
will perform poorly on certain specially chosen element sets.)</p>
<p>Amortized complexity refers to average complexity over many calls.  For example,
insertion has expected constant complexity but only amortized one: occasionally
insertion will trigger a non-constant rehashing.  Similarly, in a non-linked table
<tt class="docutils literal">operator++</tt> on an iterator has O(<tt class="docutils literal"><span class="pre">bucket_count()&nbsp;/&nbsp;size()</span></tt>) amortized complexity.
In this case complexity should be averaged not just over consecutive calls, but over
calls on different iterators pointing at all the elements in the table.</p>
</blockquote>
</div>
<div class="section" id="differences-with-tr1-containers">
<h1><a class="toc-backref" href="#id325">Differences With TR1 Containers</a></h1>
<p>MCT classes try to be as compatible as possible with containers from the standard library.
Still, there are differences.</p>
<div class="section" id="conceptual-differences">
<h2><a class="toc-backref" href="#id326">Conceptual Differences</a></h2>
<ul class="simple">
<li>Rehashing or insertion, which can indirectly cause it, invalidate pointers and
references to elements, not only iterators.  This is because under closed hashing scheme
all elements are stored in a single memory block.</li>
<li>MCT classes lack local iterators and all related member functions.  The concept simply
makes no sense for closed hashing.  So, the following members are not defined:<ul>
<li>types <tt class="docutils literal">local_iterator</tt> and <tt class="docutils literal">const_local_iterator</tt>;</li>
<li>functions <tt class="docutils literal"><span class="pre">bucket&nbsp;(key)</span></tt>, <tt class="docutils literal"><span class="pre">bucket_size&nbsp;(n)</span></tt>, <tt class="docutils literal"><span class="pre">begin&nbsp;(n)</span></tt>, <tt class="docutils literal"><span class="pre">cbegin&nbsp;(n)</span></tt>,
<tt class="docutils literal"><span class="pre">end&nbsp;(n)</span></tt> and <tt class="docutils literal"><span class="pre">cend&nbsp;(n)</span></tt>.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="mct-limitations">
<h2><a class="toc-backref" href="#id327">MCT Limitations</a></h2>
<ul class="simple">
<li>MCT requires that hash function type and equality predicate types have non-throwing copy
constructors.</li>
</ul>
</div>
<div class="section" id="unique-to-mct">
<h2><a class="toc-backref" href="#id328">Unique to MCT</a></h2>
<ul class="simple">
<li><tt class="docutils literal">keep_hashes</tt> template parameter (some standard library implementations have it too,
as an extension).</li>
<li>Non-standard <tt class="docutils literal">quick_erase()</tt> member function (also present in Boost).</li>
<li>Several debugging helpers; see <a class="reference internal" href="#common-debugging-members">Common Debugging Members</a> and <a class="reference internal" href="#automated-debugging">Automated Debugging</a>
sections for details.</li>
<li><tt class="docutils literal">linked_hash_*</tt> and <tt class="docutils literal">forward_hash_*</tt> containers provide stable iteration order.</li>
</ul>
</div>
</div>
<div class="section" id="recipes">
<h1><a class="toc-backref" href="#id329">Recipes</a></h1>
<p>This section could also be titled “How to...”.</p>
<div class="section" id="choosing-the-best-hash-table">
<h2><a class="toc-backref" href="#id330">Choosing the Best Hash Table</a></h2>
<p>Advices in this section are partially based on various benchmarks, partially on educated
guesses.  Take them with a grain of salt.  Since they are quite speculative, you are
advised to <em>always benchmark various implementations</em> for your particular case if
performance is important enough.</p>
<p>The advices below are mostly concerned with picking hashing principle among the following:</p>
<ul class="simple">
<li>closed hashing: for example, MCT itself or <a class="reference external" href="http://code.google.com/p/google-sparsehash/">Google SparseHash library</a>;</li>
<li>open hashing: any implementation of <tt class="docutils literal">unordered_*</tt> containers (in <a class="reference external" href="http://www.boost.org/doc/libs">Boost</a> or the
standard library);</li>
<li>intrusive open hashing: see <tt class="docutils literal">unordered_*</tt> containers in Boost Intrusive library; note
that they are not as generic as other implementations and require additional support
from contained values — that’s why “intrusive” in the name.</li>
</ul>
<p>Just pick the best description of your situation below.</p>
<p><strong>I need pointers and references to elements to be always valid</strong></p>
<blockquote>
Use open hashing.  With closed hashing this cannot be guaranteed.</blockquote>
<p><strong>My hash table will be read-only after some point</strong></p>
<blockquote>
In this situation, closed hashing should be generally faster unless elements are
really large.  Don’t forget to purge erased elements (<tt class="docutils literal"><span class="pre">rehash&nbsp;(0)</span></tt> in MCT classes)
when switching to read-only mode.</blockquote>
<p><strong>I have small elements: ints or pointers or small structures of those</strong></p>
<blockquote>
Use closed hashing.  The smaller the elements are, the more pronounced performance
difference with open hashing will be.</blockquote>
<p><strong>The elements are fairly large or “own” largish allocated memory chunks</strong></p>
<blockquote>
Use open hashing.  Even better, if you can afford the additional inconveniences,
intrusive open hashing.</blockquote>
<p><strong>I need to avoid memory allocation on each insert</strong></p>
<blockquote>
Presumably because memory allocator requires synchronization between threads.  Here
you have several options: closed hashing, intrusive open hashing or open hashing with
a specially-tailored allocator that avoids locking by e.g. using a memory pool.  To
choose one of these you probably need to consider other aspects like element size and
coding difficulty.</blockquote>
<p><strong>Table consists of many fairly small elements and I need to conserve memory</strong></p>
<blockquote>
Use Google’s <tt class="docutils literal">sparse_hash_set</tt> or <tt class="docutils literal">sparse_hash_map</tt>.  Those are slower, but are
superior to other implementations in memory footprint.</blockquote>
</div>
<div class="section" id="implementing-a-cache-of-limited-size">
<h2><a class="toc-backref" href="#id331">Implementing a Cache of Limited Size</a></h2>
<p>One fairly common task is to cache results of some computation.  Results are typically
cached by arguments to computation function.  If domain of those arguments is huge, it is
often impossible to keep entire cache in memory, simply because memory is finite.  In such
cases one needs to limit cache size.  There are several different strategies:</p>
<ul class="simple">
<li>if limit is reached, don’t cache any further results;</li>
<li>if limit is reached, delete arbitrary entry before adding another;</li>
<li>if limit is reached, delete the least useful entry before adding another.</li>
</ul>
<p>This section concerns the third option.  “Least useful” is a fairly vague term and can be
defined in many different ways, depending on exact needs and/or easiness of
implementation.  We will further narrow the scope of this section by considering <em>the
oldest entry</em>.</p>
<p>To implement a cache with this property, one could use either <tt class="docutils literal">forward_hash_map</tt> or
<tt class="docutils literal">linked_hash_map</tt> — not because they use closed hashing, that’s irrelevant here, but
because the containers are linked.  Implementation could look like this:</p>
<pre class="literal-block">
typedef  forward_hash_map &lt;key_type, result_type&gt;  cache_map;
   // or linked_hash_map &lt;...&gt; if you need extra functionality

result_type
compute_result (const key_type&amp; key)
{
  cache_map::iterator  entry = cache.find (key);
  if (entry != cache.end ())
    return entry.second;

  result_type  result = /* some real computation */;

  if (cache.size () &gt;= limit)
    cache.pop_front ();
  cache.insert (make_pair (key, result));
  return result;
}
</pre>
<p>Here <tt class="docutils literal">cache</tt> is a variable of type <tt class="docutils literal">cache_type</tt> and <tt class="docutils literal">limit</tt> is some integral value.
Since <tt class="docutils literal">insert()</tt> adds an element at the very end of iteration order, <tt class="docutils literal">pop_front()</tt> can
be used to remove the oldest (in insertion terms) element.</p>
<p>If the cache is a <tt class="docutils literal">linked_hash_map</tt>, you can use <tt class="docutils literal">relink()</tt> to alter iteration order.
For instance, adding:</p>
<pre class="literal-block">
cache.relink (cache.end (), entry);
</pre>
<p>in the found entry case above, will make <tt class="docutils literal">pop_front()</tt> erase <em>the least recently used</em>
element, not just the least recently added.</p>
<p>Remember, however, that forward and linked maps use more memory than plain maps, so you
should consider whether benefits outweigh this drawback.</p>
</div>
<div class="section" id="implementing-queue-or-stack-with-lookup">
<h2><a class="toc-backref" href="#id332">Implementing Queue or Stack With Lookup</a></h2>
<p>Occasionally, it is useful to have queue or stack with fast lookup — for instance, to
avoid adding an item which is already added.  With traditional array or list
implementation, lookup time is proportional to structure size.  However, with a
hash table-backed implementation you can reduce that to O(1) expected time.</p>
<p>For a queue or stack functionality, a hash table needs to be linked.  However, supported
operations of <tt class="docutils literal">forward_hash_set</tt> (or <tt class="docutils literal">forward_hash_map</tt> if you need) are just enough
in this case and, since these containers are more efficient than <tt class="docutils literal">linked_hash_*</tt>, their
use is preferable.</p>
<p>Popping (item removing) in <tt class="docutils literal">forward_hash_*</tt> can only be done at one end, but since
pushing (item adding) at both ends is possible, this is enough to implement both queue and
stack semantics with the same data structure.  To implement a queue, use <tt class="docutils literal">push_back()</tt>
and <tt class="docutils literal">pop_front()</tt> functions; for a stack, use <tt class="docutils literal">push_front()</tt> and <tt class="docutils literal">pop_front()</tt>.</p>
<p>Don’t forget, however, that hash tables won’t allow duplicate elements.  Also remember
that the only advantage here is the fast lookup (and no-duplicates restriction if that’s
actually desirable in your case).  If you don’t need lookup functionality or use it only
occasionally, implementation based on array or linked list will almost certainly be more
efficient.  Additionally, because of associated overhead, hash table implementation will
be slower if the queue/stack remains tiny (just a few elements) all the time.</p>
</div>
<div class="section" id="improving-performance-of-containers-at-no-storage-cost">
<h2><a class="toc-backref" href="#id333">Improving Performance of Containers at No Storage Cost</a></h2>
<p>In certain cases it is possible to speed up <tt class="docutils literal">closed_hash_set</tt> and <tt class="docutils literal">closed_hash_map</tt>
even further without incurring any increase in memory footprint.  This is no magic — it is
possible only if there are “holes” in the stored values that can be used by the containers
for internal purposes.  So, this can only be done for certain composite user types, and
even then is not automatic, as you need to provide some information to MCT about where
these “holes” are and how to use them.</p>
<p>Instead of adding yet another template parameter, MCT containers check whether
<tt class="docutils literal"><span class="pre">mct::external_use</span></tt> template is specialized for the value type — or, for
<tt class="docutils literal">closed_hash_map</tt>, either for <tt class="docutils literal">key_type</tt> or <tt class="docutils literal">mapped_type</tt>.  Currently (as of 1.4)
the only allowed way to specialize the template is to inherit from
<tt class="docutils literal"><span class="pre">mct::extern_use_field</span></tt>.</p>
<p>Suppose you have the following class:</p>
<pre class="literal-block">
struct Person
{
  std::string     name;
  unsigned short  age;
  bool            gender;
};
</pre>
<p>Because of alignment rules (at least on modern real-world architectures), this structure
can be extended with a <tt class="docutils literal">char</tt> field without increasing its layout size:</p>
<pre class="literal-block">
  ...
  bool            gender;
  char            _unused;
};
</pre>
<p>Now we can tell MCT that the field <tt class="docutils literal">_unused</tt> is specifically reserved for the containers
and won’t be used by the class itself like this:</p>
<pre class="literal-block">
namespace mct
{
  template &lt;&gt;
  struct external_use &lt;Person&gt; : extern_use_field &lt;Person, char, &amp;Person::_unused&gt;
  { };
}
</pre>
<p>If such a declaration is present, containers like <tt class="docutils literal"><span class="pre">closed_hash_set&nbsp;&lt;Person&gt;</span></tt>,
<tt class="docutils literal"><span class="pre">closed_hash_map&nbsp;&lt;int,&nbsp;Person&gt;</span></tt> and so on will use a more efficient representation.</p>
<p>Remember, however, that the class must not use the field <em>at all</em> (except possibly in
constructors), not even in its assignment operator.  In particular, a type that dedicates
a field for external use <em>must not</em> have an implicit assignment operator.</p>
<p>More details and examples can be found in the <a class="reference internal" href="#external-use-specification">External Use Specification</a> reference
section.</p>
</div>
</div>
<div class="section" id="performance-tips">
<h1><a class="toc-backref" href="#id334">Performance Tips</a></h1>
<p>Most tips here just reiterate what is said elsewhere.  The section is only meant to give a
concise summary of the most performance-sensitive aspects.</p>
<p>Hash function</p>
<blockquote>
A good hash function is the most important factor in performance of any hash-based
container.  You can check if given function works well by using facilities described
in <a class="reference internal" href="#common-debugging-members">Common Debugging Members</a> reference section.</blockquote>
<p>Linked containers</p>
<blockquote>
While linked containers have functional advantages, this comes at a price, both in
performance and memory footprint.  Don’t use them unless you actually need stable
iteration order.</blockquote>
<p>Forward containers</p>
<blockquote>
Forward containers should be used in place of linked ones if the supported
functionality is enough for given usecase.  They both use less memory and are faster.
However, some missing functions (e.g. erase-by-key) are important and can certainly
make these containers unsuitable in many cases.</blockquote>
<p>External use information</p>
<blockquote>
If you use <tt class="docutils literal">closed_hash_*</tt> containers with a composite element type, consider if it
is possible to specialize <tt class="docutils literal"><span class="pre">mct::external_use</span></tt> template for it.  If you can do this,
the containers for the type will automatically use a more efficient implementation.</blockquote>
<p><tt class="docutils literal">keep_hashes</tt></p>
<blockquote>
If element comparison function is slow, you can try to reduce number of calls to it by
forcing containers to remember contained element hashes: set <tt class="docutils literal">keep_hashes</tt> template
parameter to <tt class="docutils literal">true</tt>.  If hashes are kept, two elements with different hashes are
never compared against each other as they cannot be equal anyway.  Remember, however,
that for very fast equality function performance impact may be even negative.</blockquote>
<p>Erased elements</p>
<blockquote>
<p>MCT classes use closed hashing scheme with <a class="reference external" href="http://en.wikipedia.org/wiki/Quadratic_probing">quadratic probing</a>.  With this scheme it
is impossible to (efficiently) mark a bucket as empty.  So, an erased bucket still
remains occupied, only marked as not containing real data.  Such buckets (termed
<em>debris</em>) slow down both element lookup and further container modifications.</p>
<p>Containers will automatically get rid of debris if they are too many.  However, this
operation is quite slow, so it is not done from time to time.  If you want, you can
force such cleanup by rehashing the container with its current number of buckets.
This is especially useful if you are done with modification and from now on the
container will be used for lookup only.</p>
</blockquote>
<p>Empty hash tables</p>
<blockquote>
<p>When you create a new, empty table, it will not allocate internal bucket array from
the start.  However, if you insert some elements and subsequently erase all of them,
the table is left empty, but with allocated bucket array.  This is intentional and
prevents frequent reallocations for uses where a table is frequently cleared only to
be filled again.</p>
<p>However, if you actually want to clear a hash table <em>and</em> make it release dynamic
memory at the same time, simply assign a newly constructed empty table:</p>
<pre class="literal-block">
map = closed_hash_map &lt;...&gt; ();
</pre>
<p>Additionally, this will have constant complexity provided that map’s <tt class="docutils literal">value_type</tt>
has trivial destructor.</p>
<p>You can also tell an empty container to release dynamic memory by using any rehashing
operation, e.g. by calling <tt class="docutils literal">reserve()</tt> or <tt class="docutils literal">rehash()</tt>.</p>
</blockquote>
<p>Increasing number of buckets</p>
<blockquote>
Rehashing is relatively slow operation.  So, if you expect many insertions, it is
almost always a good idea to preemptively increase number of buckets in a container
accordingly by using its <tt class="docutils literal">reserve()</tt> or <tt class="docutils literal">rehash()</tt> function.  Likewise, it pays
off to specify initial number of buckets if you can estimate that well enough.</blockquote>
<p>Reducing number of buckets (shrinking container)</p>
<blockquote>
<p>While having a low load factor (i.e. many more buckets than elements) usually only
benefits performance because there are less hash collisions, the issue is not
clear-cut.  Sometimes increased memory consumption can make a container slower,
because of CPU memory cache misses, or because total program footprint nears physical
memory size.</p>
<p>Containers in MCT deliberately never shrink themselves.  It seems there is no
auto-shrinking strategy that is beneficial often enough yet doesn’t penalize other use
cases noticeably.  However, you can manually ask a container to shrink by using its
<tt class="docutils literal">reserve()</tt> or <tt class="docutils literal">rehash()</tt> function.</p>
</blockquote>
<p>Swapping containers</p>
<blockquote>
Swapping two containers with equal allocators is an O(1) operation.  However, if
allocators are different, the operation is slow: O(<em>n</em>) where <em>n</em> is the total number
of buckets.  If, for some reason, you use different allocators, keep this in mind.</blockquote>
</div>
<div class="section" id="reference">
<h1><a class="toc-backref" href="#id335">Reference</a></h1>
<p>This section diligently lists and documents every public member of MCT classes.  Non-class
functions that are closely related to a class (e.g. <tt class="docutils literal">swap()</tt> for class objects) are
listed in that class section.  There is also a section for <a class="reference internal" href="#cross-container-functions">Cross-Container Functions</a>.</p>
<p>Not all function descriptions explicitly specify exception safety level.  If a function
documentation doesn’t mention exceptions at all, it can be assumed to never throw
anything.  If possible exceptions are listed, but safety level is not specified, it can be
assumed to be strong safety.  Still, in certain “important cases” safety level is
specified explicitly even if it matches the default.</p>
<div class="section" id="closed-hash-set">
<h2><a class="toc-backref" href="#id336"><tt class="docutils literal">closed_hash_set</tt></a></h2>
<p>A fast unordered container with unique values.</p>
<p>Iterators are invalidated by all <tt class="docutils literal">insert()</tt> variants, setter function
<tt class="docutils literal"><span class="pre">max_load_factor&nbsp;(float)</span></tt> and <tt class="docutils literal">rehash()</tt>.  All member and associated non-member
functions apart from the range insertion provide strong exception safety.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#definition" id="id352">Definition</a></li>
<li><a class="reference internal" href="#type-members" id="id353">Type Members</a></li>
<li><a class="reference internal" href="#constructors-copy-and-destructor" id="id354">Constructors, Copy and Destructor</a><ul>
<li><a class="reference internal" href="#id7" id="id355"><tt class="docutils literal">closed_hash_set <span class="pre">([...])</span></tt></a></li>
<li><a class="reference internal" href="#closed-hash-set-that" id="id356"><tt class="docutils literal">closed_hash_set (that)</tt></a></li>
<li><a class="reference internal" href="#closed-hash-set-that-allocator" id="id357"><tt class="docutils literal">closed_hash_set (that, allocator)</tt></a></li>
<li><a class="reference internal" href="#template-closed-hash-set-first-last" id="id358"><tt class="docutils literal">template closed_hash_set (first, last, <span class="pre">[...])</span></tt></a></li>
<li><a class="reference internal" href="#closed-hash-set-values" id="id359"><tt class="docutils literal">closed_hash_set ({ <span class="pre">values...</span> }, <span class="pre">[...])</span></tt></a></li>
<li><a class="reference internal" href="#operator-that" id="id360"><tt class="docutils literal">operator= (that)</tt></a></li>
<li><a class="reference internal" href="#operator-values" id="id361"><tt class="docutils literal">operator= ({ <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#id8" id="id362"><tt class="docutils literal">~closed_hash_set ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#size-and-capacity" id="id363">Size and Capacity</a><ul>
<li><a class="reference internal" href="#empty" id="id364"><tt class="docutils literal">empty ()</tt></a></li>
<li><a class="reference internal" href="#size" id="id365"><tt class="docutils literal">size ()</tt></a></li>
<li><a class="reference internal" href="#max-size" id="id366"><tt class="docutils literal">max_size ()</tt></a></li>
<li><a class="reference internal" href="#bucket-count" id="id367"><tt class="docutils literal">bucket_count ()</tt></a></li>
<li><a class="reference internal" href="#max-bucket-count" id="id368"><tt class="docutils literal">max_bucket_count ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#iterators" id="id369">Iterators</a><ul>
<li><a class="reference internal" href="#begin" id="id370"><tt class="docutils literal">begin ()</tt></a></li>
<li><a class="reference internal" href="#cbegin" id="id371"><tt class="docutils literal">cbegin ()</tt></a></li>
<li><a class="reference internal" href="#end" id="id372"><tt class="docutils literal">end ()</tt></a></li>
<li><a class="reference internal" href="#cend" id="id373"><tt class="docutils literal">cend ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-lookup" id="id374">Data Lookup</a><ul>
<li><a class="reference internal" href="#find-key" id="id375"><tt class="docutils literal">find (key)</tt></a></li>
<li><a class="reference internal" href="#count-key" id="id376"><tt class="docutils literal">count (key)</tt></a></li>
<li><a class="reference internal" href="#equal-range-key" id="id377"><tt class="docutils literal">equal_range (key)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#container-modifications" id="id378">Container Modifications</a><ul>
<li><a class="reference internal" href="#insert-value" id="id379"><tt class="docutils literal">insert (value)</tt></a></li>
<li><a class="reference internal" href="#insert-hint-value" id="id380"><tt class="docutils literal">insert (hint, value)</tt></a></li>
<li><a class="reference internal" href="#template-insert-first-last" id="id381"><tt class="docutils literal">template insert (first, last)</tt></a></li>
<li><a class="reference internal" href="#insert-values" id="id382"><tt class="docutils literal">insert ({ <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#template-emplace-args" id="id383"><tt class="docutils literal">template emplace (args)</tt></a></li>
<li><a class="reference internal" href="#template-emplace-hint-hint-args" id="id384"><tt class="docutils literal">template emplace_hint (hint, args)</tt></a></li>
<li><a class="reference internal" href="#erase-key" id="id385"><tt class="docutils literal">erase (key)</tt></a></li>
<li><a class="reference internal" href="#erase-iterator" id="id386"><tt class="docutils literal">erase (iterator)</tt></a></li>
<li><a class="reference internal" href="#quick-erase-iterator" id="id387"><tt class="docutils literal">quick_erase (iterator)</tt></a></li>
<li><a class="reference internal" href="#erase-first-last" id="id388"><tt class="docutils literal">erase (first, last)</tt></a></li>
<li><a class="reference internal" href="#clear" id="id389"><tt class="docutils literal">clear ()</tt></a></li>
<li><a class="reference internal" href="#swap-that" id="id390"><tt class="docutils literal">swap (that)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hashing-policy" id="id391">Hashing Policy</a><ul>
<li><a class="reference internal" href="#load-factor" id="id392"><tt class="docutils literal">load_factor ()</tt></a></li>
<li><a class="reference internal" href="#max-load-factor" id="id393"><tt class="docutils literal">max_load_factor ()</tt></a></li>
<li><a class="reference internal" href="#max-load-factor-set-to" id="id394"><tt class="docutils literal">max_load_factor (set_to)</tt></a></li>
<li><a class="reference internal" href="#rehash-num-buckets" id="id395"><tt class="docutils literal">rehash (num_buckets)</tt></a></li>
<li><a class="reference internal" href="#reserve-num-elements" id="id396"><tt class="docutils literal">reserve (num_elements)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#construction-parameter-queries" id="id397">Construction Parameter Queries</a><ul>
<li><a class="reference internal" href="#hash-function" id="id398"><tt class="docutils literal">hash_function ()</tt></a></li>
<li><a class="reference internal" href="#key-eq" id="id399"><tt class="docutils literal">key_eq ()</tt></a></li>
<li><a class="reference internal" href="#get-allocator" id="id400"><tt class="docutils literal">get_allocator ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#non-member-functions" id="id401">Non-Member Functions</a><ul>
<li><a class="reference internal" href="#operator-set1-set2" id="id402"><tt class="docutils literal">operator== (set1, set2)</tt></a></li>
<li><a class="reference internal" href="#id9" id="id403"><tt class="docutils literal">operator!= (set1, set2)</tt></a></li>
<li><a class="reference internal" href="#swap-set1-set2" id="id404"><tt class="docutils literal">swap (set1, set2)</tt></a></li>
<li><a class="reference internal" href="#boost-serialization-serialize-archive-set-version" id="id405"><tt class="docutils literal"><span class="pre">boost::serialization::serialize</span> (archive, set, version)</tt></a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="definition">
<h3><a class="toc-backref" href="#id352">Definition</a></h3>
<p>The class is defined in header <tt class="docutils literal"><span class="pre">&lt;mct/hash-set.hpp&gt;</span></tt>:</p>
<pre class="literal-block">
template &lt;typename Value,
          typename Hash        = hash &lt;Value&gt;,
          typename Equal       = std::equal_to &lt;Value&gt;,
          typename Allocator   = std::allocator &lt;Value&gt;,
          bool     keep_hashes = false&gt;
class closed_hash_set;
</pre>
<p>Template parameters:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">Value</tt>:</th><td class="field-body">The set’s value type; must be assignable and copy-constructible</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Hash</tt>:</th><td class="field-body">A unary function object type that hashes <tt class="docutils literal">Value</tt> objects and returns an
<tt class="docutils literal"><span class="pre">std::size_t</span></tt> hash; copy constructor <em>must not</em> throw, see <a class="reference internal" href="#common-note-above">common note above</a></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Equal</tt>:</th><td class="field-body">A binary function object type used to compare objects of type <tt class="docutils literal">Value</tt>, i.e.
equality predicate; copy constructor <em>must not</em> throw, see <a class="reference internal" href="#common-note-above">common note above</a></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Allocator</tt>:</th><td class="field-body">Allocator for type <tt class="docutils literal">Value</tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">keep_hashes</tt>:</th><td class="field-body">Flag that determines whether the set keeps hashes of individual contained values
(i.e. doesn’t recompute them); see <a class="reference internal" href="#flag-description-above">flag description above</a> for details</td>
</tr>
</tbody>
</table>
</blockquote>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.2</p>
</div>
<p>If <tt class="docutils literal"><span class="pre">mct::supports_external_use</span></tt> is <tt class="docutils literal">true</tt> for <tt class="docutils literal">Value</tt>, the container will use a more
efficient implementation.</p>
</div>
<div class="section" id="type-members">
<h3><a class="toc-backref" href="#id353">Type Members</a></h3>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">key_type</tt>:</th><td class="field-body">The set’s value type (i.e. the same as <tt class="docutils literal">value_type</tt>)</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">value_type</tt>:</th><td class="field-body">The set’s value type</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">hasher</tt>:</th><td class="field-body">The type of the hash function object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">key_equal</tt>:</th><td class="field-body">The type of equality function object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">allocator_type</tt>:</th><td class="field-body">The type of allocator object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">iterator</tt>:</th><td class="field-body">A bidirectional iterator type capable of navigating the set; value it points to
cannot be modified, so this behaves just like <tt class="docutils literal">const_iterator</tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_iterator</tt>:</th><td class="field-body">A constant bidirectional iterator; for sets this behaves exactly as <tt class="docutils literal">iterator</tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">pointer</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_pointer</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">reference</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_reference</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">size_type</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">difference_type</tt>:</th><td class="field-body">Standard container type members; mostly interesting for meta-programming needs</td>
</tr>
</tbody>
</table>
</blockquote>
<div class="important">
<p class="first admonition-title">Important</p>
<p class="last">In plain hash tables, increment and decrement operators of the iterators have
non-constant O(<tt class="docutils literal"><span class="pre">bucket_count()&nbsp;/&nbsp;size()</span></tt>) amortized complexity.  In particular, they
can perform poorly in almost empty sets.</p>
</div>
</div>
<div class="section" id="constructors-copy-and-destructor">
<h3><a class="toc-backref" href="#id354">Constructors, Copy and Destructor</a></h3>
<div class="section" id="id7">
<h4><a class="toc-backref" href="#id355"><tt class="docutils literal">closed_hash_set <span class="pre">([...])</span></tt></a></h4>
<pre class="literal-block">
closed_hash_set (size_type              num_buckets = 0,
                 const hasher&amp;          hash        = hasher (),
                 const key_equal&amp;       equal       = key_equal (),
                 const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create an empty set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant, but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt> on first
element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="closed-hash-set-that">
<h4><a class="toc-backref" href="#id356"><tt class="docutils literal">closed_hash_set (that)</tt></a></h4>
<pre class="literal-block">
closed_hash_set (const closed_hash_set&amp; that);
</pre>
<p>Create a new set as a copy of another.  Copies contained elements, hash function object,
equality predicate, allocator and maximum load factor of the other container.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected O(<tt class="docutils literal">that.bucket_count()</tt>); worst case
O(<tt class="docutils literal"><span class="pre">that.bucket_count()&nbsp;*&nbsp;that.size()</span></tt>).  If <tt class="docutils literal">that</tt> is empty: constant,
but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt> on first element
insertion.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
closed_hash_set (closed_hash_set&amp;&amp; that);
</pre>
<p>The same as copy constructor, except that the second set is left in undefined state.
Unlike the copy constructor, this never throws.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="closed-hash-set-that-allocator">
<h4><a class="toc-backref" href="#id357"><tt class="docutils literal">closed_hash_set (that, allocator)</tt></a></h4>
<pre class="literal-block">
closed_hash_set (const closed_hash_set&amp; that, const allocator_type&amp; allocator);
</pre>
<p>Similar to the copy constructor, but uses explicitly specified <tt class="docutils literal">allocator</tt> instead of
copying it from <tt class="docutils literal">that</tt> container.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for copy constructor.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="template-closed-hash-set-first-last">
<h4><a class="toc-backref" href="#id358"><tt class="docutils literal">template closed_hash_set (first, last, <span class="pre">[...])</span></tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
closed_hash_set (InputIterator          first,
                 InputIterator          last,
                 size_type              num_buckets = 0,
                 const hasher&amp;          hash        = hasher (),
                 const key_equal&amp;       equal       = key_equal (),
                 const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create a set containing all elements in the range <tt class="docutils literal">[first, last)</tt>.  Duplicate elements
in the range are effectively ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in maximum of range size and <tt class="docutils literal">num_buckets</tt>; worst case
quadratic in range size.  If <tt class="docutils literal"><span class="pre">first&nbsp;==&nbsp;last</span></tt>: constant, but with certain
allocation linear in <tt class="docutils literal">bucket_count()</tt> on first element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="closed-hash-set-values">
<h4><a class="toc-backref" href="#id359"><tt class="docutils literal">closed_hash_set ({ <span class="pre">values...</span> }, <span class="pre">[...])</span></tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This constructor is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
closed_hash_set (std::initializer_list &lt;value_type&gt; initializer,
                 size_type              num_buckets = 0,
                 const hasher&amp;          hash        = hasher (),
                 const key_equal&amp;       equal       = key_equal (),
                 const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create a set containing all elements from <tt class="docutils literal">initializer</tt> list.  Duplicate elements are
effectively ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in maximum of number of <tt class="docutils literal">values</tt> and <tt class="docutils literal">num_buckets</tt>;
worst case quadratic in number of <tt class="docutils literal">values</tt>.  If the initializer list is
empty: constant, but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt>
on first element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="operator-that">
<h4><a class="toc-backref" href="#id360"><tt class="docutils literal">operator= (that)</tt></a></h4>
<pre class="literal-block">
closed_hash_set&amp;  operator= (const closed_hash_set&amp; that);
</pre>
<p>Erase current set contents and replace it with contents of another set.  This replaces
hash function, equality predicate and maximum load factor, but not the allocator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.
Also see <a class="reference internal" href="#common-note-above">common note above</a>.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for destructor plus copy constructor.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
closed_hash_set&amp;  operator= (closed_hash_set&amp;&amp; that);
</pre>
<p>The same as copy assignment, except that the second set is left in undefined state.
If allocators of the two sets are equal this version doesn’t throw.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for destructor if allocators of this and <tt class="docutils literal">that</tt> sets are equal;
otherwise same as for destructor plus copy constructor.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="operator-values">
<h4><a class="toc-backref" href="#id361"><tt class="docutils literal">operator= ({ <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This assignment is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
closed_hash_set&amp;  operator= (std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Erase current set contents and replace it with values from the <tt class="docutils literal">initializers</tt>.
Duplicate elements in the list are effectively ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in number of values; worst case quadratic in number of
values.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id8">
<h4><a class="toc-backref" href="#id362"><tt class="docutils literal">~closed_hash_set ()</tt></a></h4>
<p>Destroy all contained elements, free memory and destroy the set itself.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if <tt class="docutils literal">value_type</tt> has a trivial destructor or the set is empty;
linear in <tt class="docutils literal">bucket_count()</tt> otherwise.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="size-and-capacity">
<h3><a class="toc-backref" href="#id363">Size and Capacity</a></h3>
<div class="section" id="empty">
<h4><a class="toc-backref" href="#id364"><tt class="docutils literal">empty ()</tt></a></h4>
<pre class="literal-block">
bool  empty ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the set is empty, i.e. if <tt class="docutils literal">size () == 0</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="size">
<h4><a class="toc-backref" href="#id365"><tt class="docutils literal">size ()</tt></a></h4>
<pre class="literal-block">
size_type  size ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of elements in the set.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="max-size">
<h4><a class="toc-backref" href="#id366"><tt class="docutils literal">max_size ()</tt></a></h4>
<pre class="literal-block">
size_type  max_size ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The largest size this set could ever have.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="bucket-count">
<h4><a class="toc-backref" href="#id367"><tt class="docutils literal">bucket_count ()</tt></a></h4>
<pre class="literal-block">
size_type  bucket_count ()  const;
</pre>
<p>Determine the number of buckets in the container.  For sets with allocated bucket array
this is the number of allocated buckets (not including private buckets, if any).  For
empty containers this is the number the container will allocate when needed.  So, the
return value is always non-zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Current number of buckets.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="max-bucket-count">
<h4><a class="toc-backref" href="#id368"><tt class="docutils literal">max_bucket_count ()</tt></a></h4>
<pre class="literal-block">
size_type  max_bucket_count ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The largest number of buckets this set could ever have.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="iterators">
<h3><a class="toc-backref" href="#id369">Iterators</a></h3>
<div class="section" id="begin">
<h4><a class="toc-backref" href="#id370"><tt class="docutils literal">begin ()</tt></a></h4>
<pre class="literal-block">
iterator        begin ();
const_iterator  begin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the first element in the set, or past-the-end
iterator if the set is empty.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body"><tt class="docutils literal">closed_hash_set</tt> doesn’t give any guarantees about iteration order.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">O(<tt class="docutils literal">bucket_count() / size()</tt>); constant in empty sets.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cbegin">
<h4><a class="toc-backref" href="#id371"><tt class="docutils literal">cbegin ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cbegin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A constant iterator pointing to the first element in the set, or
past-the-end iterator if the set is empty.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body"><tt class="docutils literal">closed_hash_set</tt> doesn’t give any guarantees about iteration order.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">O(<tt class="docutils literal">bucket_count() / size()</tt>); constant in empty sets.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="end">
<h4><a class="toc-backref" href="#id372"><tt class="docutils literal">end ()</tt></a></h4>
<pre class="literal-block">
iterator        end ();
const_iterator  end ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end iterator for the set.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cend">
<h4><a class="toc-backref" href="#id373"><tt class="docutils literal">cend ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cend ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end iterator for the set.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="data-lookup">
<h3><a class="toc-backref" href="#id374">Data Lookup</a></h3>
<div class="section" id="find-key">
<h4><a class="toc-backref" href="#id375"><tt class="docutils literal">find (key)</tt></a></h4>
<pre class="literal-block">
iterator        find (const key_type&amp; key);
const_iterator  find (const key_type&amp; key)  const;
</pre>
<p>Find an element with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to matching element or <tt class="docutils literal">end()</tt> if there’s no such
element.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="count-key">
<h4><a class="toc-backref" href="#id376"><tt class="docutils literal">count (key)</tt></a></h4>
<pre class="literal-block">
size_type  count (const key_type&amp; key)  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of elements with given <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a set return value is always 0 or 1.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="equal-range-key">
<h4><a class="toc-backref" href="#id377"><tt class="docutils literal">equal_range (key)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, iterator&gt;              equal_range (const key_type&amp; key);
std::pair &lt;const_iterator, const_iterator&gt;  equal_range (const key_type&amp; key)  const;
</pre>
<p>Determine the range consisting of all elements with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair <tt class="docutils literal">P</tt> such that <tt class="docutils literal">[P.first, P.second)</tt> is the range consisting
all elements with given <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a set such a range always contains 0 or 1 element.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="container-modifications">
<h3><a class="toc-backref" href="#id378">Container Modifications</a></h3>
<p>Note that all <tt class="docutils literal">insert()</tt> variants invalidate iterators while all <tt class="docutils literal">erase()</tt> don’t.</p>
<div class="section" id="insert-value">
<h4><a class="toc-backref" href="#id379"><tt class="docutils literal">insert (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the set unless the set already contains an equal one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="insert-hint-value">
<h4><a class="toc-backref" href="#id380"><tt class="docutils literal">insert (hint, value)</tt></a></h4>
<pre class="literal-block">
iterator  insert (const_iterator hint, const value_type&amp; value);
</pre>
<p>Currently <tt class="docutils literal">hint</tt> is simply ignored and effect is the same as <tt class="docutils literal"><span class="pre">insert&nbsp;(value)</span></tt>.</p>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
iterator  insert (const_iterator hint, value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="template-insert-first-last">
<h4><a class="toc-backref" href="#id381"><tt class="docutils literal">template insert (first, last)</tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
void  insert (InputIterator first, InputIterator last);
</pre>
<p>Insert all values in the range <tt class="docutils literal">[first, last)</tt> into the set.  Values that are equal to
any already contained are effectively ignored.  This is equivalent to calling single-item
<tt class="docutils literal">insert()</tt> on each value in the range, but using this function might be more efficient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Basic exception safety: if an exception is thrown,
the set contents is as before plus maybe part of contents of the range.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="insert-values">
<h4><a class="toc-backref" href="#id382"><tt class="docutils literal">insert ({ <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
void  insert (std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Insert given <tt class="docutils literal">values</tt> into the set.  Values that are equal to any already contained are
effectively ignored.  This is equivalent to calling single-item <tt class="docutils literal">insert()</tt> on each value
in the list, but using this function might be more efficient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Basic exception safety: if an exception is thrown,
the set contents is as before plus maybe part of contents of the initializer
list.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="template-emplace-args">
<h4><a class="toc-backref" href="#id383"><tt class="docutils literal">template emplace (args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace (Args&amp;&amp;... args);
</pre>
<p>Insert a <tt class="docutils literal">value_type</tt> object constructed with given arguments into the set unless the
set already contains an equal one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">Purpose of this function in the standard <tt class="docutils literal">unordered_set</tt> is to avoid moving or
copying the constructed object.  Unfortunately, this is impossible to achieve with
closed hashing, so in <tt class="docutils literal">closed_hash_set</tt> this is not faster than simple <tt class="docutils literal">insert()</tt>.
This function exists mostly for compatibility reasons.</p>
</div>
</div>
<div class="section" id="template-emplace-hint-hint-args">
<h4><a class="toc-backref" href="#id384"><tt class="docutils literal">template emplace_hint (hint, args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace (const_iterator hint, Args&amp;&amp;... args);
</pre>
<p>Currently <tt class="docutils literal">hint</tt> is simply ignored and effect is the same as <tt class="docutils literal"><span class="pre">emplace&nbsp;(args)</span></tt>.</p>
</div>
<div class="section" id="erase-key">
<h4><a class="toc-backref" href="#id385"><tt class="docutils literal">erase (key)</tt></a></h4>
<pre class="literal-block">
size_type  erase (const key_type&amp; key);
</pre>
<p>Erase an element with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of erased elements; might be zero.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a set return value is always 0 or 1.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="erase-iterator">
<h4><a class="toc-backref" href="#id386"><tt class="docutils literal">erase (iterator)</tt></a></h4>
<pre class="literal-block">
iterator  erase (const_iterator position);
</pre>
<p>Erase the element at given <tt class="docutils literal">position</tt> and return an iterator to the next one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the next element or <tt class="docutils literal">end()</tt> if there’s no next
element.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.  This function has non-constant complexity and can perform
poorly in almost empty sets.  See also <tt class="docutils literal">quick_erase()</tt> below.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">O(<tt class="docutils literal">bucket_count() / size()</tt>) amortized.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="quick-erase-iterator">
<h4><a class="toc-backref" href="#id387"><tt class="docutils literal">quick_erase (iterator)</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.4</p>
</div>
<pre class="literal-block">
void  quick_erase (const_iterator position);
</pre>
<p>Erase the element at given <tt class="docutils literal">position</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="erase-first-last">
<h4><a class="toc-backref" href="#id388"><tt class="docutils literal">erase (first, last)</tt></a></h4>
<pre class="literal-block">
iterator  erase (const_iterator first, const_iterator last);
</pre>
<p>Erase a range of elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the element following the range — i.e. <tt class="docutils literal">last</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">O(<tt class="docutils literal">n * bucket_count() / size()</tt>) amortized, where <tt class="docutils literal">n</tt> is the distance
between <tt class="docutils literal">first</tt> and <tt class="docutils literal">last</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="clear">
<h4><a class="toc-backref" href="#id389"><tt class="docutils literal">clear ()</tt></a></h4>
<pre class="literal-block">
void  clear ();
</pre>
<p>Erase all elements in the set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in <tt class="docutils literal">bucket_count()</tt>.  Constant for empty sets.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="swap-that">
<h4><a class="toc-backref" href="#id390"><tt class="docutils literal">swap (that)</tt></a></h4>
<pre class="literal-block">
void  swap (closed_hash_set&amp; that);
</pre>
<p>Swap contents (elements), hash function, equality predicates and maximum load factors
between two sets.  Allocators are not swapped.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Only if allocators are different: exceptions thrown by (either set’s) hash
function, equality predicates or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">If the allocators are equal the function never throws. Otherwise strong
exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if the allocators are equal.  Otherwise the same as copying the
two sets, see the copy constructor.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="hashing-policy">
<h3><a class="toc-backref" href="#id391">Hashing Policy</a></h3>
<div class="section" id="load-factor">
<h4><a class="toc-backref" href="#id392"><tt class="docutils literal">load_factor ()</tt></a></h4>
<pre class="literal-block">
float  load_factor ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Current load factor of the container.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="max-load-factor">
<h4><a class="toc-backref" href="#id393"><tt class="docutils literal">max_load_factor ()</tt></a></h4>
<pre class="literal-block">
float  max_load_factor ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Maximum allowed load factor of the container.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="max-load-factor-set-to">
<h4><a class="toc-backref" href="#id394"><tt class="docutils literal">max_load_factor (set_to)</tt></a></h4>
<pre class="literal-block">
void  max_load_factor (float set_to);
</pre>
<p>Change maximum load factor of the set.  If the new maximum is smaller than the current
load factor, the set is rehashed to reduce the load.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators if a rehash is trigerred.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if <tt class="docutils literal"><span class="pre">load_factor()&nbsp;&lt;&nbsp;set_to</span></tt>; otherwise same as for <tt class="docutils literal">rehash()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="rehash-num-buckets">
<h4><a class="toc-backref" href="#id395"><tt class="docutils literal">rehash (num_buckets)</tt></a></h4>
<pre class="literal-block">
void  rehash (size_type num_buckets);
</pre>
<p>Change bucket count to given value, if possible.  Implementation can alter <tt class="docutils literal">num_buckets</tt>
as needed to have load factor small enough as well as for internal reasons.  In
particular, it is legal to specify zero as number of buckets: this will be replaced with
the smallest number that keeps load below the allowed maximum.  Finally, it sometimes
makes sense (for performance) to rehash to the same number of buckets as before to “clean”
the container after erasing elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">bucket_count()</tt>; worst case
O(<tt class="docutils literal"><span class="pre">bucket_count()&nbsp;*&nbsp;size()</span></tt>).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="reserve-num-elements">
<h4><a class="toc-backref" href="#id396"><tt class="docutils literal">reserve (num_elements)</tt></a></h4>
<pre class="literal-block">
void  reserve (size_type num_elements);
</pre>
<p>Rehash the table in such a way that it will not be rehashed anymore if size doesn’t exceed
given value and no <tt class="docutils literal">erase()</tt>-like functions are used.  This is exactly identical to:</p>
<pre class="literal-block">
set.rehash (std::ceil (num_elements / set.max_load_factor ()));
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for <tt class="docutils literal">rehash()</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="construction-parameter-queries">
<h3><a class="toc-backref" href="#id397">Construction Parameter Queries</a></h3>
<div class="section" id="hash-function">
<h4><a class="toc-backref" href="#id398"><tt class="docutils literal">hash_function ()</tt></a></h4>
<pre class="literal-block">
hasher  hash_function ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Set’s hash function object.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="key-eq">
<h4><a class="toc-backref" href="#id399"><tt class="docutils literal">key_eq ()</tt></a></h4>
<pre class="literal-block">
key_equal  key_eq ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Set’s equality predicate object.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-allocator">
<h4><a class="toc-backref" href="#id400"><tt class="docutils literal">get_allocator ()</tt></a></h4>
<pre class="literal-block">
allocator_type  get_allocator ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Set’s allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="non-member-functions">
<h3><a class="toc-backref" href="#id401">Non-Member Functions</a></h3>
<div class="section" id="operator-set1-set2">
<h4><a class="toc-backref" href="#id402"><tt class="docutils literal">operator== (set1, set2)</tt></a></h4>
<pre class="literal-block">
operator== (const closed_hash_set &lt;...&gt;&amp; set1, const closed_hash_set &lt;...&gt;&amp; set2);
</pre>
<p>Compare the elements of the two sets.</p>
<p>See also more generic <tt class="docutils literal">operator==</tt> in <a class="reference internal" href="#cross-container-functions">Cross-Container Functions</a> section.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the sets are equal, i.e. contain the same elements.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Result is undefined if the sets’ equality predicates are not equivalent.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected O(<tt class="docutils literal">bucket_count()</tt>); worst case O(<tt class="docutils literal"><span class="pre">bucket_count()&nbsp;*&nbsp;size()</span></tt>).
Optimizations: constant for comparing a set with itself or comparing sets of
different sizes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id9">
<h4><a class="toc-backref" href="#id403"><tt class="docutils literal">operator!= (set1, set2)</tt></a></h4>
<pre class="literal-block">
operator!= (const closed_hash_set &lt;...&gt;&amp; set1, const closed_hash_set &lt;...&gt;&amp; set2);
</pre>
<p>See <tt class="docutils literal">operator==</tt> for details.</p>
</div>
<div class="section" id="swap-set1-set2">
<h4><a class="toc-backref" href="#id404"><tt class="docutils literal">swap (set1, set2)</tt></a></h4>
<pre class="literal-block">
void  swap (closed_hash_set &lt;...&gt;&amp; set1, closed_hash_set &lt;...&gt;&amp; set2);
</pre>
<p>Effect is identical to <tt class="docutils literal">set1.swap (set2)</tt>.  See the function for details.</p>
</div>
<div class="section" id="boost-serialization-serialize-archive-set-version">
<h4><a class="toc-backref" href="#id405"><tt class="docutils literal"><span class="pre">boost::serialization::serialize</span> (archive, set, version)</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.6</p>
</div>
<p>A function defined in a separate header <tt class="docutils literal"><span class="pre">&lt;mct/hash-set-serialization.hpp&gt;</span></tt>.  Allows to
serialize and unserialize closed hash sets using common Boost.Serialization mechanisms.</p>
</div>
</div>
</div>
<div class="section" id="closed-hash-map">
<h2><a class="toc-backref" href="#id337"><tt class="docutils literal">closed_hash_map</tt></a></h2>
<p>A fast unordered container mapping unique keys to arbitrary values.</p>
<p>Iterators are invalidated by all <tt class="docutils literal">insert()</tt> variants, <tt class="docutils literal">operator[]</tt>, setter function
<tt class="docutils literal"><span class="pre">max_load_factor&nbsp;(float)</span></tt> and <tt class="docutils literal">rehash()</tt>.  All member and associated non-member
functions apart from the range insertion provide strong exception safety.</p>
<div class="contents local topic" id="id10">
<ul class="simple">
<li><a class="reference internal" href="#id11" id="id406">Definition</a></li>
<li><a class="reference internal" href="#id12" id="id407">Type Members</a></li>
<li><a class="reference internal" href="#id13" id="id408">Constructors, Copy and Destructor</a><ul>
<li><a class="reference internal" href="#id14" id="id409"><tt class="docutils literal">closed_hash_map <span class="pre">([...])</span></tt></a></li>
<li><a class="reference internal" href="#closed-hash-map-that" id="id410"><tt class="docutils literal">closed_hash_map (that)</tt></a></li>
<li><a class="reference internal" href="#closed-hash-map-that-allocator" id="id411"><tt class="docutils literal">closed_hash_map (that, allocator)</tt></a></li>
<li><a class="reference internal" href="#template-closed-hash-map-first-last" id="id412"><tt class="docutils literal">template closed_hash_map (first, last, <span class="pre">[...])</span></tt></a></li>
<li><a class="reference internal" href="#closed-hash-map-values" id="id413"><tt class="docutils literal">closed_hash_map ({ <span class="pre">values...</span> }, <span class="pre">[...])</span></tt></a></li>
<li><a class="reference internal" href="#id15" id="id414"><tt class="docutils literal">operator= (that)</tt></a></li>
<li><a class="reference internal" href="#id16" id="id415"><tt class="docutils literal">operator= ({ <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#id17" id="id416"><tt class="docutils literal">~closed_hash_map ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id18" id="id417">Size and Capacity</a><ul>
<li><a class="reference internal" href="#id19" id="id418"><tt class="docutils literal">empty ()</tt></a></li>
<li><a class="reference internal" href="#id20" id="id419"><tt class="docutils literal">size ()</tt></a></li>
<li><a class="reference internal" href="#id21" id="id420"><tt class="docutils literal">max_size ()</tt></a></li>
<li><a class="reference internal" href="#id22" id="id421"><tt class="docutils literal">bucket_count ()</tt></a></li>
<li><a class="reference internal" href="#id23" id="id422"><tt class="docutils literal">max_bucket_count ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id24" id="id423">Iterators</a><ul>
<li><a class="reference internal" href="#id25" id="id424"><tt class="docutils literal">begin ()</tt></a></li>
<li><a class="reference internal" href="#id26" id="id425"><tt class="docutils literal">cbegin ()</tt></a></li>
<li><a class="reference internal" href="#id27" id="id426"><tt class="docutils literal">end ()</tt></a></li>
<li><a class="reference internal" href="#id28" id="id427"><tt class="docutils literal">cend ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id29" id="id428">Data Lookup</a><ul>
<li><a class="reference internal" href="#id30" id="id429"><tt class="docutils literal">find (key)</tt></a></li>
<li><a class="reference internal" href="#id31" id="id430"><tt class="docutils literal">count (key)</tt></a></li>
<li><a class="reference internal" href="#id32" id="id431"><tt class="docutils literal">equal_range (key)</tt></a></li>
<li><a class="reference internal" href="#operator-key" id="id432"><tt class="docutils literal">operator[] (key)</tt></a></li>
<li><a class="reference internal" href="#at-key" id="id433"><tt class="docutils literal">at (key)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id33" id="id434">Container Modifications</a><ul>
<li><a class="reference internal" href="#id34" id="id435"><tt class="docutils literal">insert (value)</tt></a></li>
<li><a class="reference internal" href="#id35" id="id436"><tt class="docutils literal">insert (hint, value)</tt></a></li>
<li><a class="reference internal" href="#id36" id="id437"><tt class="docutils literal">template insert (first, last)</tt></a></li>
<li><a class="reference internal" href="#id37" id="id438"><tt class="docutils literal">insert ({ <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#id38" id="id439"><tt class="docutils literal">template emplace (args)</tt></a></li>
<li><a class="reference internal" href="#id39" id="id440"><tt class="docutils literal">template emplace_hint (hint, args)</tt></a></li>
<li><a class="reference internal" href="#id40" id="id441"><tt class="docutils literal">erase (key)</tt></a></li>
<li><a class="reference internal" href="#id41" id="id442"><tt class="docutils literal">erase (iterator)</tt></a></li>
<li><a class="reference internal" href="#id42" id="id443"><tt class="docutils literal">quick_erase (iterator)</tt></a></li>
<li><a class="reference internal" href="#id43" id="id444"><tt class="docutils literal">erase (first, last)</tt></a></li>
<li><a class="reference internal" href="#id44" id="id445"><tt class="docutils literal">clear ()</tt></a></li>
<li><a class="reference internal" href="#id45" id="id446"><tt class="docutils literal">swap (that)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id46" id="id447">Hashing Policy</a><ul>
<li><a class="reference internal" href="#id47" id="id448"><tt class="docutils literal">load_factor ()</tt></a></li>
<li><a class="reference internal" href="#id48" id="id449"><tt class="docutils literal">max_load_factor ()</tt></a></li>
<li><a class="reference internal" href="#id49" id="id450"><tt class="docutils literal">max_load_factor (set_to)</tt></a></li>
<li><a class="reference internal" href="#id50" id="id451"><tt class="docutils literal">rehash (num_buckets)</tt></a></li>
<li><a class="reference internal" href="#id51" id="id452"><tt class="docutils literal">reserve (num_elements)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id52" id="id453">Construction Parameter Queries</a><ul>
<li><a class="reference internal" href="#id53" id="id454"><tt class="docutils literal">hash_function ()</tt></a></li>
<li><a class="reference internal" href="#id54" id="id455"><tt class="docutils literal">key_eq ()</tt></a></li>
<li><a class="reference internal" href="#id55" id="id456"><tt class="docutils literal">get_allocator ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id56" id="id457">Non-Member Functions</a><ul>
<li><a class="reference internal" href="#operator-map1-map2" id="id458"><tt class="docutils literal">operator== (map1, map2)</tt></a></li>
<li><a class="reference internal" href="#id57" id="id459"><tt class="docutils literal">operator!= (map1, map2)</tt></a></li>
<li><a class="reference internal" href="#swap-map1-map2" id="id460"><tt class="docutils literal">swap (map1, map2)</tt></a></li>
<li><a class="reference internal" href="#boost-serialization-serialize-archive-map-version" id="id461"><tt class="docutils literal"><span class="pre">boost::serialization::serialize</span> (archive, map, version)</tt></a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id406">Definition</a></h3>
<p>The class is defined in header <tt class="docutils literal"><span class="pre">&lt;mct/hash-map.hpp&gt;</span></tt>:</p>
<pre class="literal-block">
template &lt;typename Key,
          typename Mapped,
          typename Hash        = hash &lt;Key&gt;,
          typename Equal       = std::equal_to &lt;Key&gt;,
          typename Allocator   = std::allocator &lt;std::pair &lt;const Key, Mapped&gt; &gt;,
          bool     keep_hashes = false&gt;
class closed_hash_map;
</pre>
<p>Template parameters:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">Key</tt>:</th><td class="field-body">The map’s key type; must be assignable and copy-constructible</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Mapped</tt>:</th><td class="field-body">The type keys are mapped to; must be copy-constructible</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Hash</tt>:</th><td class="field-body">A unary function object type that hashes <tt class="docutils literal">Key</tt> objects and returns an
<tt class="docutils literal"><span class="pre">std::size_t</span></tt> hash; copy constructor <em>must not</em> throw, see <a class="reference internal" href="#common-note-above">common note above</a></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Equal</tt>:</th><td class="field-body">A binary function object type used to compare objects of type <tt class="docutils literal">Key</tt>, i.e.
equality predicate; copy constructor <em>must not</em> throw, see <a class="reference internal" href="#common-note-above">common note above</a></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Allocator</tt>:</th><td class="field-body">Allocator for type <tt class="docutils literal"><span class="pre">std::pair</span> &lt;const Key, Mapped&gt;</tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">keep_hashes</tt>:</th><td class="field-body">Flag that determines whether the map keeps hashes of individual contained keys
(i.e. doesn’t recompute them); see <a class="reference internal" href="#flag-description-above">flag description above</a> for details</td>
</tr>
</tbody>
</table>
</blockquote>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.2</p>
</div>
<p>If <tt class="docutils literal"><span class="pre">mct::supports_external_use</span></tt> is <tt class="docutils literal">true</tt> for <tt class="docutils literal">Key</tt> or <tt class="docutils literal">Mapped</tt> (or both), the
container will use a more efficient implementation.</p>
</div>
<div class="section" id="id12">
<h3><a class="toc-backref" href="#id407">Type Members</a></h3>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">key_type</tt>:</th><td class="field-body">The map’s key type</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">mapped_type</tt>:</th><td class="field-body">The type keys are mapped to</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">value_type</tt>:</th><td class="field-body">The map’s value type; always <tt class="docutils literal"><span class="pre">std::pair&nbsp;&lt;const&nbsp;key_type,&nbsp;mapped_type&gt;</span></tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">hasher</tt>:</th><td class="field-body">The type of the hash function object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">key_equal</tt>:</th><td class="field-body">The type of equality function object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">allocator_type</tt>:</th><td class="field-body">The type of allocator object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">iterator</tt>:</th><td class="field-body">A bidirectional iterator type capable of navigating the map; note that the
iterator is not mutable because <tt class="docutils literal">first</tt> member of the pair it points to cannot
be modified</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_iterator</tt>:</th><td class="field-body">A constant bidirectional iterator; similar to <tt class="docutils literal">iterator</tt> except that values it
points to are immutable</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">pointer</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_pointer</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">reference</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_reference</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">size_type</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">difference_type</tt>:</th><td class="field-body">Standard container type members; mostly interesting for meta-programming needs</td>
</tr>
</tbody>
</table>
</blockquote>
<div class="important">
<p class="first admonition-title">Important</p>
<p class="last">In plain hash tables, increment and decrement operators of the iterators have
non-constant O(<tt class="docutils literal"><span class="pre">bucket_count()&nbsp;/&nbsp;size()</span></tt>) amortized complexity.  In particular, they
can perform poorly in almost empty maps.</p>
</div>
</div>
<div class="section" id="id13">
<h3><a class="toc-backref" href="#id408">Constructors, Copy and Destructor</a></h3>
<div class="section" id="id14">
<h4><a class="toc-backref" href="#id409"><tt class="docutils literal">closed_hash_map <span class="pre">([...])</span></tt></a></h4>
<pre class="literal-block">
closed_hash_map (size_type              num_buckets = 0,
                 const hasher&amp;          hash        = hasher (),
                 const key_equal&amp;       equal       = key_equal (),
                 const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create an empty map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant, but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt> on first
element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="closed-hash-map-that">
<h4><a class="toc-backref" href="#id410"><tt class="docutils literal">closed_hash_map (that)</tt></a></h4>
<pre class="literal-block">
closed_hash_map (const closed_hash_map&amp; that);
</pre>
<p>Create a new map as a copy of another.  Copies contained elements, hash function object,
equality predicate, allocator and maximum load factor of the other container.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected O(<tt class="docutils literal">that.bucket_count()</tt>); worst case
O(<tt class="docutils literal"><span class="pre">that.bucket_count()&nbsp;*&nbsp;that.size()</span></tt>).  If <tt class="docutils literal">that</tt> is empty: constant,
but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt> on first element
insertion.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
closed_hash_map (closed_hash_map&amp;&amp; that);
</pre>
<p>The same as copy constructor, except that the second map is left in undefined state.
Unlike the copy constructor, this never throws.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="closed-hash-map-that-allocator">
<h4><a class="toc-backref" href="#id411"><tt class="docutils literal">closed_hash_map (that, allocator)</tt></a></h4>
<pre class="literal-block">
closed_hash_map (const closed_hash_map&amp; that, const allocator_type&amp; allocator);
</pre>
<p>Similar to the copy constructor, but uses explicitly specified <tt class="docutils literal">allocator</tt> instead of
copying it from <tt class="docutils literal">that</tt> container.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for copy constructor.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="template-closed-hash-map-first-last">
<h4><a class="toc-backref" href="#id412"><tt class="docutils literal">template closed_hash_map (first, last, <span class="pre">[...])</span></tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
closed_hash_map (InputIterator          first,
                 InputIterator          last,
                 size_type              num_buckets = 0,
                 const hasher&amp;          hash        = hasher (),
                 const key_equal&amp;       equal       = key_equal (),
                 const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create a map containing all elements in the range <tt class="docutils literal">[first, last)</tt>.  Elements with
duplicate keys in the range are effectively ignored: only the first is inserted into the
new map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in maximum of range size and <tt class="docutils literal">num_buckets</tt>; worst case
quadratic in range size.  If <tt class="docutils literal"><span class="pre">first&nbsp;==&nbsp;last</span></tt>: constant, but with certain
allocation linear in <tt class="docutils literal">bucket_count()</tt> on first element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="closed-hash-map-values">
<h4><a class="toc-backref" href="#id413"><tt class="docutils literal">closed_hash_map ({ <span class="pre">values...</span> }, <span class="pre">[...])</span></tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This constructor is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
closed_hash_map (std::initializer_list &lt;value_type&gt; initializer,
                 size_type              num_buckets = 0,
                 const hasher&amp;          hash        = hasher (),
                 const key_equal&amp;       equal       = key_equal (),
                 const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create a map containing all elements from <tt class="docutils literal">initializer</tt> list.  Elements with duplicate
keys are effectively ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in maximum of number of <tt class="docutils literal">values</tt> and <tt class="docutils literal">num_buckets</tt>;
worst case quadratic in number of <tt class="docutils literal">values</tt>.  If the initializer list is
empty: constant, but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt>
on first element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id15">
<h4><a class="toc-backref" href="#id414"><tt class="docutils literal">operator= (that)</tt></a></h4>
<pre class="literal-block">
closed_hash_map&amp;  operator= (const closed_hash_map&amp; that);
</pre>
<p>Erase current map contents and replace it with contents of another map.  This replaces
hash function, equality predicate and maximum load factor, but not the allocator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.
Also see <a class="reference internal" href="#common-note-above">common note above</a>.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for destructor plus copy constructor.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
closed_hash_map&amp;  operator= (closed_hash_map&amp;&amp; that);
</pre>
<p>The same as copy assignment, except that the second map is left in undefined state.
If allocators of the two maps are equal this version doesn’t throw.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for destructor if allocators of this and <tt class="docutils literal">that</tt> maps are equal;
otherwise same as for destructor plus copy constructor.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id16">
<h4><a class="toc-backref" href="#id415"><tt class="docutils literal">operator= ({ <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This assignment is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
closed_hash_map&amp;  operator= (std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Erase current map contents and replace it with values from the <tt class="docutils literal">initializers</tt>.
Elements with duplicate keys in the list are effectively ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in number of values; worst case quadratic in number of
values.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id17">
<h4><a class="toc-backref" href="#id416"><tt class="docutils literal">~closed_hash_map ()</tt></a></h4>
<p>Destroy all contained elements, free memory and destroy the map itself.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if <tt class="docutils literal">value_type</tt> has a trivial destructor or the map is empty;
linear in <tt class="docutils literal">bucket_count()</tt> otherwise.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id18">
<h3><a class="toc-backref" href="#id417">Size and Capacity</a></h3>
<div class="section" id="id19">
<h4><a class="toc-backref" href="#id418"><tt class="docutils literal">empty ()</tt></a></h4>
<pre class="literal-block">
bool  empty ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the map is empty, i.e. if <tt class="docutils literal">size () == 0</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id20">
<h4><a class="toc-backref" href="#id419"><tt class="docutils literal">size ()</tt></a></h4>
<pre class="literal-block">
size_type  size ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of elements in the map.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id21">
<h4><a class="toc-backref" href="#id420"><tt class="docutils literal">max_size ()</tt></a></h4>
<pre class="literal-block">
size_type  max_size ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The largest size this map could ever have.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id22">
<h4><a class="toc-backref" href="#id421"><tt class="docutils literal">bucket_count ()</tt></a></h4>
<pre class="literal-block">
size_type  bucket_count ()  const;
</pre>
<p>Determine the number of buckets in the container.  For maps with allocated bucket array
this is the number of allocated buckets (not including private buckets, if any).  For
empty containers this is the number the container will allocate when needed.  So, the
return value is always non-zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Current number of buckets.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id23">
<h4><a class="toc-backref" href="#id422"><tt class="docutils literal">max_bucket_count ()</tt></a></h4>
<pre class="literal-block">
size_type  max_bucket_count ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The largest number of buckets this map could ever have.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id24">
<h3><a class="toc-backref" href="#id423">Iterators</a></h3>
<div class="section" id="id25">
<h4><a class="toc-backref" href="#id424"><tt class="docutils literal">begin ()</tt></a></h4>
<pre class="literal-block">
iterator        begin ();
const_iterator  begin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the first element in the map, or past-the-end
iterator if the map is empty.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body"><tt class="docutils literal">closed_hash_map</tt> doesn’t give any guarantees about iteration order.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">O(<tt class="docutils literal">bucket_count() / size()</tt>); constant in empty maps.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id26">
<h4><a class="toc-backref" href="#id425"><tt class="docutils literal">cbegin ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cbegin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A constant iterator pointing to the first element in the map, or
past-the-end iterator if the map is empty.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body"><tt class="docutils literal">closed_hash_map</tt> doesn’t give any guarantees about iteration order.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">O(<tt class="docutils literal">bucket_count() / size()</tt>); constant in empty maps.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id27">
<h4><a class="toc-backref" href="#id426"><tt class="docutils literal">end ()</tt></a></h4>
<pre class="literal-block">
iterator        end ();
const_iterator  end ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end iterator for the map.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id28">
<h4><a class="toc-backref" href="#id427"><tt class="docutils literal">cend ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cend ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end iterator for the map.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id29">
<h3><a class="toc-backref" href="#id428">Data Lookup</a></h3>
<div class="section" id="id30">
<h4><a class="toc-backref" href="#id429"><tt class="docutils literal">find (key)</tt></a></h4>
<pre class="literal-block">
iterator        find (const key_type&amp; key);
const_iterator  find (const key_type&amp; key)  const;
</pre>
<p>Find an element with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to matching element or <tt class="docutils literal">end()</tt> if there’s no such
element.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id31">
<h4><a class="toc-backref" href="#id430"><tt class="docutils literal">count (key)</tt></a></h4>
<pre class="literal-block">
size_type  count (const key_type&amp; key)  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of elements with given <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a map return value is always 0 or 1.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id32">
<h4><a class="toc-backref" href="#id431"><tt class="docutils literal">equal_range (key)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, iterator&gt;              equal_range (const key_type&amp; key);
std::pair &lt;const_iterator, const_iterator&gt;  equal_range (const key_type&amp; key)  const;
</pre>
<p>Determine the range consisting of all elements with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair <tt class="docutils literal">P</tt> such that <tt class="docutils literal">[P.first, P.second)</tt> is the range consisting
all elements with given <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a map such a range always contains 0 or 1 element.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="operator-key">
<h4><a class="toc-backref" href="#id432"><tt class="docutils literal">operator[] (key)</tt></a></h4>
<pre class="literal-block">
mapped_type&amp;  operator[] (const key_type&amp; key);
</pre>
<p>Find the object given <tt class="docutils literal">key</tt> is mapped to, or else insert a new association with
default-constructed <tt class="docutils literal">mapped_type</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A reference to a pre-existed or newly inserted object associated with
<tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators if a new association is created.  Strong exception
safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="at-key">
<h4><a class="toc-backref" href="#id433"><tt class="docutils literal">at (key)</tt></a></h4>
<pre class="literal-block">
mapped_type&amp;        at (const key_type&amp; key);
const mapped_type&amp;  at (const key_type&amp; key)  const;
</pre>
<p>Find the element with given <tt class="docutils literal">key</tt> and assert its presence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A reference to the pre-existed object associated with <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body"><tt class="docutils literal"><span class="pre">std::out_of_range</span></tt> if there is no element with given <tt class="docutils literal">key</tt> (the
assertion fails).  Additionally, exceptions thrown by the hash function or
equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id33">
<h3><a class="toc-backref" href="#id434">Container Modifications</a></h3>
<p>Note that all <tt class="docutils literal">insert()</tt> variants invalidate iterators while all <tt class="docutils literal">erase()</tt> don’t.</p>
<div class="section" id="id34">
<h4><a class="toc-backref" href="#id435"><tt class="docutils literal">insert (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the map unless the map already contains one with equal
key.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or pre-existed with equal key)
element and a flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="id35">
<h4><a class="toc-backref" href="#id436"><tt class="docutils literal">insert (hint, value)</tt></a></h4>
<pre class="literal-block">
iterator  insert (const_iterator hint, const value_type&amp; value);
</pre>
<p>Currently <tt class="docutils literal">hint</tt> is simply ignored and effect is the same as <tt class="docutils literal"><span class="pre">insert&nbsp;(value)</span></tt>.</p>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
iterator  insert (const_iterator hint, value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="id36">
<h4><a class="toc-backref" href="#id437"><tt class="docutils literal">template insert (first, last)</tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
void  insert (InputIterator first, InputIterator last);
</pre>
<p>Insert all values in the range <tt class="docutils literal">[first, last)</tt> into the map.  Values with keys that are
equal to any already contained are effectively ignored.  This is equivalent to calling
single-item <tt class="docutils literal">insert()</tt> on each value in the range, but using this function might be more
efficient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Basic exception safety: if an exception is thrown,
the map contents is as before plus maybe part of contents of the range.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id37">
<h4><a class="toc-backref" href="#id438"><tt class="docutils literal">insert ({ <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
void  insert (std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Insert given <tt class="docutils literal">values</tt> into the map.  Values with keys that are equal to any already
contained are effectively ignored.  This is equivalent to calling single-item <tt class="docutils literal">insert()</tt>
on each value in the list, but using this function might be more efficient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Basic exception safety: if an exception is thrown,
the map contents is as before plus maybe part of contents of the initializer
list.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id38">
<h4><a class="toc-backref" href="#id439"><tt class="docutils literal">template emplace (args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace (Args&amp;&amp;... args);
</pre>
<p>Insert a <tt class="docutils literal">value_type</tt> object constructed with given arguments into the map unless the
map already contains one with equal key.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">Purpose of this function in the standard <tt class="docutils literal">unordered_map</tt> is to avoid moving or
copying the constructed object.  Unfortunately, this is impossible to achieve with
closed hashing, so in <tt class="docutils literal">closed_hash_map</tt> this is not faster than simple <tt class="docutils literal">insert()</tt>.
This function exists mostly for compatibility reasons.</p>
</div>
</div>
<div class="section" id="id39">
<h4><a class="toc-backref" href="#id440"><tt class="docutils literal">template emplace_hint (hint, args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace (const_iterator hint, Args&amp;&amp;... args);
</pre>
<p>Currently <tt class="docutils literal">hint</tt> is simply ignored and effect is the same as <tt class="docutils literal"><span class="pre">emplace&nbsp;(args)</span></tt>.</p>
</div>
<div class="section" id="id40">
<h4><a class="toc-backref" href="#id441"><tt class="docutils literal">erase (key)</tt></a></h4>
<pre class="literal-block">
size_type  erase (const key_type&amp; key);
</pre>
<p>Erase an element with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of erased elements; might be zero.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a map return value is always 0 or 1.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id41">
<h4><a class="toc-backref" href="#id442"><tt class="docutils literal">erase (iterator)</tt></a></h4>
<pre class="literal-block">
iterator  erase (const_iterator position);
</pre>
<p>Erase the element at given <tt class="docutils literal">position</tt> and return an iterator to the next one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the next element or <tt class="docutils literal">end()</tt> if there’s no next
element.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.  This function has non-constant complexity and can perform
poorly in almost empty maps.  See also <tt class="docutils literal">quick_erase()</tt> below.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">O(<tt class="docutils literal">bucket_count() / size()</tt>) amortized.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id42">
<h4><a class="toc-backref" href="#id443"><tt class="docutils literal">quick_erase (iterator)</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.4</p>
</div>
<pre class="literal-block">
void  quick_erase (const_iterator position);
</pre>
<p>Erase the element at given <tt class="docutils literal">position</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id43">
<h4><a class="toc-backref" href="#id444"><tt class="docutils literal">erase (first, last)</tt></a></h4>
<pre class="literal-block">
iterator  erase (const_iterator first, const_iterator last);
</pre>
<p>Erase a range of elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the element following the range — i.e. <tt class="docutils literal">last</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">O(<tt class="docutils literal">n * bucket_count() / size()</tt>) amortized, where <tt class="docutils literal">n</tt> is the distance
between <tt class="docutils literal">first</tt> and <tt class="docutils literal">last</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id44">
<h4><a class="toc-backref" href="#id445"><tt class="docutils literal">clear ()</tt></a></h4>
<pre class="literal-block">
void  clear ();
</pre>
<p>Erase all elements in the map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in <tt class="docutils literal">bucket_count()</tt>.  Constant for empty maps.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id45">
<h4><a class="toc-backref" href="#id446"><tt class="docutils literal">swap (that)</tt></a></h4>
<pre class="literal-block">
void  swap (closed_hash_map&amp; that);
</pre>
<p>Swap contents (elements), hash function, equality predicates and maximum load factors
between two maps.  Allocators are not swapped.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Only if allocators are different: exceptions thrown by (either map’s) hash
function, equality predicates or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">If the allocators are equal the function never throws. Otherwise strong
exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if the allocators are equal.  Otherwise the same as copying the
two maps, see the copy constructor.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id46">
<h3><a class="toc-backref" href="#id447">Hashing Policy</a></h3>
<div class="section" id="id47">
<h4><a class="toc-backref" href="#id448"><tt class="docutils literal">load_factor ()</tt></a></h4>
<pre class="literal-block">
float  load_factor ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Current load factor of the container.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id48">
<h4><a class="toc-backref" href="#id449"><tt class="docutils literal">max_load_factor ()</tt></a></h4>
<pre class="literal-block">
float  max_load_factor ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Maximum allowed load factor of the container.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id49">
<h4><a class="toc-backref" href="#id450"><tt class="docutils literal">max_load_factor (set_to)</tt></a></h4>
<pre class="literal-block">
void  max_load_factor (float set_to);
</pre>
<p>Change maximum load factor of the map.  If the new maximum is smaller than the current
load factor, the map is rehashed to reduce the load.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators if a rehash is trigerred.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if <tt class="docutils literal"><span class="pre">load_factor()&nbsp;&lt;&nbsp;set_to</span></tt>; otherwise same as for <tt class="docutils literal">rehash()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id50">
<h4><a class="toc-backref" href="#id451"><tt class="docutils literal">rehash (num_buckets)</tt></a></h4>
<pre class="literal-block">
void  rehash (size_type num_buckets);
</pre>
<p>Change bucket count to given value, if possible.  Implementation can alter <tt class="docutils literal">num_buckets</tt>
as needed to have load factor small enough as well as for internal reasons.  In
particular, it is legal to specify zero as number of buckets: this will be replaced with
the smallest number that keeps load below the allowed maximum.  Finally, it sometimes
makes sense (for performance) to rehash to the same number of buckets as before to “clean”
the container after erasing elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">bucket_count()</tt>; worst case
O(<tt class="docutils literal"><span class="pre">bucket_count()&nbsp;*&nbsp;size()</span></tt>).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id51">
<h4><a class="toc-backref" href="#id452"><tt class="docutils literal">reserve (num_elements)</tt></a></h4>
<pre class="literal-block">
void  reserve (size_type num_elements);
</pre>
<p>Rehash the table in such a way that it will not be rehashed anymore if size doesn’t exceed
given value and no <tt class="docutils literal">erase()</tt>-like functions are used.  This is exactly identical to:</p>
<pre class="literal-block">
map.rehash (std::ceil (num_elements / map.max_load_factor ()));
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for <tt class="docutils literal">rehash()</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id52">
<h3><a class="toc-backref" href="#id453">Construction Parameter Queries</a></h3>
<div class="section" id="id53">
<h4><a class="toc-backref" href="#id454"><tt class="docutils literal">hash_function ()</tt></a></h4>
<pre class="literal-block">
hasher  hash_function ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Map’s hash function object.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id54">
<h4><a class="toc-backref" href="#id455"><tt class="docutils literal">key_eq ()</tt></a></h4>
<pre class="literal-block">
key_equal  key_eq ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Map’s equality predicate object.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id55">
<h4><a class="toc-backref" href="#id456"><tt class="docutils literal">get_allocator ()</tt></a></h4>
<pre class="literal-block">
allocator_type  get_allocator ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Map’s allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id56">
<h3><a class="toc-backref" href="#id457">Non-Member Functions</a></h3>
<div class="section" id="operator-map1-map2">
<h4><a class="toc-backref" href="#id458"><tt class="docutils literal">operator== (map1, map2)</tt></a></h4>
<pre class="literal-block">
operator== (const closed_hash_map &lt;...&gt;&amp; map1, const closed_hash_map &lt;...&gt;&amp; map2);
</pre>
<p>Compare the elements of the two maps.  Second element components (<tt class="docutils literal">mapped_type</tt>) are
compared with <tt class="docutils literal">operator==</tt>, while the first (<tt class="docutils literal">key_type</tt>) — with the map equality
predicate.</p>
<p>See also more generic <tt class="docutils literal">operator==</tt> in <a class="reference internal" href="#cross-container-functions">Cross-Container Functions</a> section.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the maps are equal, i.e. contain the same elements.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Result is undefined if the maps’ equality predicates are not equivalent.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected O(<tt class="docutils literal">bucket_count()</tt>); worst case O(<tt class="docutils literal"><span class="pre">bucket_count()&nbsp;*&nbsp;size()</span></tt>).
Optimizations: constant for comparing a map with itself or comparing maps of
different sizes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id57">
<h4><a class="toc-backref" href="#id459"><tt class="docutils literal">operator!= (map1, map2)</tt></a></h4>
<pre class="literal-block">
operator!= (const closed_hash_map &lt;...&gt;&amp; map1, const closed_hash_map &lt;...&gt;&amp; map2);
</pre>
<p>See <tt class="docutils literal">operator==</tt> for details.</p>
</div>
<div class="section" id="swap-map1-map2">
<h4><a class="toc-backref" href="#id460"><tt class="docutils literal">swap (map1, map2)</tt></a></h4>
<pre class="literal-block">
void  swap (closed_hash_map &lt;...&gt;&amp; map1, closed_hash_map &lt;...&gt;&amp; map2);
</pre>
<p>Effect is identical to <tt class="docutils literal">map1.swap (map2)</tt>.  See the function for details.</p>
</div>
<div class="section" id="boost-serialization-serialize-archive-map-version">
<h4><a class="toc-backref" href="#id461"><tt class="docutils literal"><span class="pre">boost::serialization::serialize</span> (archive, map, version)</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.6</p>
</div>
<p>A function defined in a separate header <tt class="docutils literal"><span class="pre">&lt;mct/hash-map-serialization.hpp&gt;</span></tt>.  Allows to
serialize and unserialize closed hash maps using common Boost.Serialization mechanisms.</p>
</div>
</div>
</div>
<div class="section" id="linked-hash-set">
<h2><a class="toc-backref" href="#id338"><tt class="docutils literal">linked_hash_set</tt></a></h2>
<p>A fast unordered container with unique values and stable iteration order.</p>
<p>Iterators are invalidated by all <tt class="docutils literal">insert()</tt> variants, setter function
<tt class="docutils literal"><span class="pre">max_load_factor&nbsp;(float)</span></tt> and <tt class="docutils literal">rehash()</tt>.  All member and associated non-member
functions except <tt class="docutils literal">sort()</tt> provide strong exception safety.</p>
<p>Note that <tt class="docutils literal">linked_hash_set</tt> is <em>not a sequence</em> despite having many functions of the
latter.</p>
<div class="important">
<p class="first admonition-title">Important</p>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.4</p>
</div>
<p class="last">On many platforms maximum number of buckets in a <tt class="docutils literal">linked_hash_set</tt> is substantially
less than would fit in memory, though still at least <em>1 billion</em>.  If that’s important
to you, read about <a class="reference internal" href="#huge-linked-hash-tables">huge linked hash tables</a>.</p>
</div>
<div class="contents local topic" id="id58">
<ul class="simple">
<li><a class="reference internal" href="#id59" id="id462">Definition</a></li>
<li><a class="reference internal" href="#id60" id="id463">Type Members</a></li>
<li><a class="reference internal" href="#id61" id="id464">Constructors, Copy and Destructor</a><ul>
<li><a class="reference internal" href="#id62" id="id465"><tt class="docutils literal">linked_hash_set <span class="pre">([...])</span></tt></a></li>
<li><a class="reference internal" href="#linked-hash-set-that" id="id466"><tt class="docutils literal">linked_hash_set (that)</tt></a></li>
<li><a class="reference internal" href="#linked-hash-set-that-allocator" id="id467"><tt class="docutils literal">linked_hash_set (that, allocator)</tt></a></li>
<li><a class="reference internal" href="#template-linked-hash-set-first-last" id="id468"><tt class="docutils literal">template linked_hash_set (first, last, <span class="pre">[...])</span></tt></a></li>
<li><a class="reference internal" href="#linked-hash-set-values" id="id469"><tt class="docutils literal">linked_hash_set ({ <span class="pre">values...</span> }, <span class="pre">[...])</span></tt></a></li>
<li><a class="reference internal" href="#id63" id="id470"><tt class="docutils literal">operator= (that)</tt></a></li>
<li><a class="reference internal" href="#id64" id="id471"><tt class="docutils literal">operator= ({ <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#id65" id="id472"><tt class="docutils literal">~linked_hash_set ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id66" id="id473">Size and Capacity</a><ul>
<li><a class="reference internal" href="#id67" id="id474"><tt class="docutils literal">empty ()</tt></a></li>
<li><a class="reference internal" href="#id68" id="id475"><tt class="docutils literal">size ()</tt></a></li>
<li><a class="reference internal" href="#id69" id="id476"><tt class="docutils literal">max_size ()</tt></a></li>
<li><a class="reference internal" href="#id70" id="id477"><tt class="docutils literal">bucket_count ()</tt></a></li>
<li><a class="reference internal" href="#id71" id="id478"><tt class="docutils literal">max_bucket_count ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id72" id="id479">Iterators</a><ul>
<li><a class="reference internal" href="#id73" id="id480"><tt class="docutils literal">begin ()</tt></a></li>
<li><a class="reference internal" href="#id74" id="id481"><tt class="docutils literal">cbegin ()</tt></a></li>
<li><a class="reference internal" href="#id75" id="id482"><tt class="docutils literal">end ()</tt></a></li>
<li><a class="reference internal" href="#id76" id="id483"><tt class="docutils literal">cend ()</tt></a></li>
<li><a class="reference internal" href="#rbegin" id="id484"><tt class="docutils literal">rbegin ()</tt></a></li>
<li><a class="reference internal" href="#crbegin" id="id485"><tt class="docutils literal">crbegin ()</tt></a></li>
<li><a class="reference internal" href="#rend" id="id486"><tt class="docutils literal">rend ()</tt></a></li>
<li><a class="reference internal" href="#crend" id="id487"><tt class="docutils literal">crend ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id77" id="id488">Data Lookup</a><ul>
<li><a class="reference internal" href="#front" id="id489"><tt class="docutils literal">front ()</tt></a></li>
<li><a class="reference internal" href="#back" id="id490"><tt class="docutils literal">back ()</tt></a></li>
<li><a class="reference internal" href="#id78" id="id491"><tt class="docutils literal">find (key)</tt></a></li>
<li><a class="reference internal" href="#id79" id="id492"><tt class="docutils literal">count (key)</tt></a></li>
<li><a class="reference internal" href="#id80" id="id493"><tt class="docutils literal">equal_range (key)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id81" id="id494">Container Modifications</a><ul>
<li><a class="reference internal" href="#push-front-value" id="id495"><tt class="docutils literal">push_front (value)</tt></a></li>
<li><a class="reference internal" href="#push-back-value" id="id496"><tt class="docutils literal">push_back (value)</tt></a></li>
<li><a class="reference internal" href="#id82" id="id497"><tt class="docutils literal">insert (value)</tt></a></li>
<li><a class="reference internal" href="#insert-before-value" id="id498"><tt class="docutils literal">insert (before, value)</tt></a></li>
<li><a class="reference internal" href="#id83" id="id499"><tt class="docutils literal">template insert (first, last)</tt></a></li>
<li><a class="reference internal" href="#template-insert-before-first-last" id="id500"><tt class="docutils literal">template insert (before, first, last)</tt></a></li>
<li><a class="reference internal" href="#id84" id="id501"><tt class="docutils literal">insert ({ <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#insert-before-values" id="id502"><tt class="docutils literal">insert (before, { <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#id85" id="id503"><tt class="docutils literal">template emplace (args)</tt></a></li>
<li><a class="reference internal" href="#template-emplace-before-before-args" id="id504"><tt class="docutils literal">template emplace_before (before, args)</tt></a></li>
<li><a class="reference internal" href="#id86" id="id505"><tt class="docutils literal">template emplace_hint (hint, args)</tt></a></li>
<li><a class="reference internal" href="#pop-front" id="id506"><tt class="docutils literal">pop_front ()</tt></a></li>
<li><a class="reference internal" href="#pop-back" id="id507"><tt class="docutils literal">pop_back ()</tt></a></li>
<li><a class="reference internal" href="#id87" id="id508"><tt class="docutils literal">erase (key)</tt></a></li>
<li><a class="reference internal" href="#id88" id="id509"><tt class="docutils literal">erase (iterator)</tt></a></li>
<li><a class="reference internal" href="#id89" id="id510"><tt class="docutils literal">quick_erase (iterator)</tt></a></li>
<li><a class="reference internal" href="#id90" id="id511"><tt class="docutils literal">erase (first, last)</tt></a></li>
<li><a class="reference internal" href="#id91" id="id512"><tt class="docutils literal">clear ()</tt></a></li>
<li><a class="reference internal" href="#id92" id="id513"><tt class="docutils literal">swap (that)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#iteration-order-modifications" id="id514">Iteration Order Modifications</a><ul>
<li><a class="reference internal" href="#relink-before-element" id="id515"><tt class="docutils literal">relink (before, element)</tt></a></li>
<li><a class="reference internal" href="#reverse" id="id516"><tt class="docutils literal">reverse ()</tt></a></li>
<li><a class="reference internal" href="#sort-compare" id="id517"><tt class="docutils literal">sort ([compare])</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id93" id="id518">Hashing Policy</a><ul>
<li><a class="reference internal" href="#id94" id="id519"><tt class="docutils literal">load_factor ()</tt></a></li>
<li><a class="reference internal" href="#id95" id="id520"><tt class="docutils literal">max_load_factor ()</tt></a></li>
<li><a class="reference internal" href="#id96" id="id521"><tt class="docutils literal">max_load_factor (set_to)</tt></a></li>
<li><a class="reference internal" href="#id97" id="id522"><tt class="docutils literal">rehash (num_buckets)</tt></a></li>
<li><a class="reference internal" href="#id98" id="id523"><tt class="docutils literal">reserve (num_elements)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id99" id="id524">Construction Parameter Queries</a><ul>
<li><a class="reference internal" href="#id100" id="id525"><tt class="docutils literal">hash_function ()</tt></a></li>
<li><a class="reference internal" href="#id101" id="id526"><tt class="docutils literal">key_eq ()</tt></a></li>
<li><a class="reference internal" href="#id102" id="id527"><tt class="docutils literal">get_allocator ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id103" id="id528">Non-Member Functions</a><ul>
<li><a class="reference internal" href="#id104" id="id529"><tt class="docutils literal">operator== (set1, set2)</tt></a></li>
<li><a class="reference internal" href="#id105" id="id530"><tt class="docutils literal">operator!= (set1, set2)</tt></a></li>
<li><a class="reference internal" href="#id106" id="id531"><tt class="docutils literal">swap (set1, set2)</tt></a></li>
<li><a class="reference internal" href="#id107" id="id532"><tt class="docutils literal"><span class="pre">boost::serialization::serialize</span> (archive, set, version)</tt></a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id59">
<h3><a class="toc-backref" href="#id462">Definition</a></h3>
<p>The class is defined in header <tt class="docutils literal"><span class="pre">&lt;mct/hash-set.hpp&gt;</span></tt>:</p>
<pre class="literal-block">
template &lt;typename Value,
          typename Hash        = hash &lt;Value&gt;,
          typename Equal       = std::equal_to &lt;Value&gt;,
          typename Allocator   = std::allocator &lt;Value&gt;,
          bool     keep_hashes = false&gt;
class linked_hash_set;
</pre>
<p>Template parameters:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">Value</tt>:</th><td class="field-body">The set’s value type; must be assignable and copy-constructible</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Hash</tt>:</th><td class="field-body">A unary function object type that hashes <tt class="docutils literal">Value</tt> objects and returns an
<tt class="docutils literal"><span class="pre">std::size_t</span></tt> hash; copy constructor <em>must not</em> throw, see <a class="reference internal" href="#common-note-above">common note above</a></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Equal</tt>:</th><td class="field-body">A binary function object type used to compare objects of type <tt class="docutils literal">Value</tt>, i.e.
equality predicate; copy constructor <em>must not</em> throw, see <a class="reference internal" href="#common-note-above">common note above</a></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Allocator</tt>:</th><td class="field-body">Allocator for type <tt class="docutils literal">Value</tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">keep_hashes</tt>:</th><td class="field-body">Flag that determines whether the set keeps hashes of individual contained values
(i.e. doesn’t recompute them); see <a class="reference internal" href="#flag-description-above">flag description above</a> for details</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="id60">
<h3><a class="toc-backref" href="#id463">Type Members</a></h3>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">key_type</tt>:</th><td class="field-body">The set’s value type (i.e. the same as <tt class="docutils literal">value_type</tt>)</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">value_type</tt>:</th><td class="field-body">The set’s value type</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">hasher</tt>:</th><td class="field-body">The type of the hash function object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">key_equal</tt>:</th><td class="field-body">The type of equality function object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">allocator_type</tt>:</th><td class="field-body">The type of allocator object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">iterator</tt>:</th><td class="field-body">A bidirectional iterator type capable of navigating the set; value it points to
cannot be modified, so this behaves just like <tt class="docutils literal">const_iterator</tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_iterator</tt>:</th><td class="field-body">A constant bidirectional iterator; for sets this behaves exactly as <tt class="docutils literal">iterator</tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">reverse_iterator</tt>:</th><td class="field-body">A bidirectional iterator type that can be used to iterate the set backwards; value
it points to cannot be modified.</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_reverse_iterator</tt>:</th><td class="field-body">A constant bidirectional iterator type that can be used to iterate the set
backwards.</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">pointer</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_pointer</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">reference</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_reference</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">size_type</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">difference_type</tt>:</th><td class="field-body">Standard container type members; mostly interesting for meta-programming needs</td>
</tr>
</tbody>
</table>
</blockquote>
<p>In linked tables, increment and decrement operators of the iterators have constant
complexity.</p>
</div>
<div class="section" id="id61">
<h3><a class="toc-backref" href="#id464">Constructors, Copy and Destructor</a></h3>
<div class="section" id="id62">
<h4><a class="toc-backref" href="#id465"><tt class="docutils literal">linked_hash_set <span class="pre">([...])</span></tt></a></h4>
<pre class="literal-block">
linked_hash_set (size_type              num_buckets = 0,
                 const hasher&amp;          hash        = hasher (),
                 const key_equal&amp;       equal       = key_equal (),
                 const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create an empty set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant, but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt> on first
element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="linked-hash-set-that">
<h4><a class="toc-backref" href="#id466"><tt class="docutils literal">linked_hash_set (that)</tt></a></h4>
<pre class="literal-block">
linked_hash_set (const linked_hash_set&amp; that);
</pre>
<p>Create a new set as a copy of another.  Copies contained elements, hash function object,
equality predicate, allocator and maximum load factor of the other container.  Iteration
order in the copy is the same as in <tt class="docutils literal">that</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">that.size()</tt>; worst case is quadratic in
<tt class="docutils literal">that.size()</tt>.  If <tt class="docutils literal">that</tt> is empty: constant, but with certain
allocation linear in <tt class="docutils literal">bucket_count()</tt> on first element insertion.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
linked_hash_set (linked_hash_set&amp;&amp; that);
</pre>
<p>The same as copy constructor, except that the second set is left in undefined state.
Unlike the copy constructor, this never throws.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="linked-hash-set-that-allocator">
<h4><a class="toc-backref" href="#id467"><tt class="docutils literal">linked_hash_set (that, allocator)</tt></a></h4>
<pre class="literal-block">
linked_hash_set (const linked_hash_set&amp; that, const allocator_type&amp; allocator);
</pre>
<p>Similar to the copy constructor, but uses explicitly specified <tt class="docutils literal">allocator</tt> instead of
copying it from <tt class="docutils literal">that</tt> container.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for copy constructor.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="template-linked-hash-set-first-last">
<h4><a class="toc-backref" href="#id468"><tt class="docutils literal">template linked_hash_set (first, last, <span class="pre">[...])</span></tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
linked_hash_set (InputIterator          first,
                 InputIterator          last,
                 size_type              num_buckets = 0,
                 const hasher&amp;          hash        = hasher (),
                 const key_equal&amp;       equal       = key_equal (),
                 const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create a set containing all elements in the range <tt class="docutils literal">[first, last)</tt>.  Duplicate elements
in the range are effectively ignored.  Iteration order of the set matches <tt class="docutils literal">[first,
last)</tt> except for duplicate elements: as only the first copy is added to the set, it is
also the only visited during iteration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in maximum of range size and <tt class="docutils literal">num_buckets</tt>; worst case
quadratic in range size.  If <tt class="docutils literal"><span class="pre">first&nbsp;==&nbsp;last</span></tt>: constant, but with certain
allocation linear in <tt class="docutils literal">bucket_count()</tt> on first element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="linked-hash-set-values">
<h4><a class="toc-backref" href="#id469"><tt class="docutils literal">linked_hash_set ({ <span class="pre">values...</span> }, <span class="pre">[...])</span></tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This constructor is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
linked_hash_set (std::initializer_list &lt;value_type&gt; initializer,
                 size_type              num_buckets = 0,
                 const hasher&amp;          hash        = hasher (),
                 const key_equal&amp;       equal       = key_equal (),
                 const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create a set containing all elements from <tt class="docutils literal">initializer</tt> list.  Duplicate elements are
effectively ignored.  Iteration order of other elements in the new set is the same as in
the list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in maximum of number of <tt class="docutils literal">values</tt> and <tt class="docutils literal">num_buckets</tt>;
worst case quadratic in number of <tt class="docutils literal">values</tt>.  If the initializer list is
empty: constant, but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt>
on first element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id63">
<h4><a class="toc-backref" href="#id470"><tt class="docutils literal">operator= (that)</tt></a></h4>
<pre class="literal-block">
linked_hash_set&amp;  operator= (const linked_hash_set&amp; that);
</pre>
<p>Erase current set contents and replace it with contents of another set.  This replaces
hash function, equality predicate and maximum load factor, but not the allocator.  After
assignment, iteration order of the two sets is the same.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.
Also see <a class="reference internal" href="#common-note-above">common note above</a>.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for destructor plus copy constructor.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
linked_hash_set&amp;  operator= (linked_hash_set&amp;&amp; that);
</pre>
<p>The same as copy assignment, except that the second set is left in undefined state.
If allocators of the two sets are equal this version doesn’t throw.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for destructor if allocators of this and <tt class="docutils literal">that</tt> sets are equal;
otherwise same as for destructor plus copy constructor.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id64">
<h4><a class="toc-backref" href="#id471"><tt class="docutils literal">operator= ({ <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This assignment is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
linked_hash_set&amp;  operator= (std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Erase current set contents and replace it with values from the <tt class="docutils literal">initializers</tt>.
Duplicate elements in the list are effectively ignored.  Iteration order of other elements
matches their relative order in the initialization list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in number of values; worst case quadratic in number of
values.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id65">
<h4><a class="toc-backref" href="#id472"><tt class="docutils literal">~linked_hash_set ()</tt></a></h4>
<p>Destroy all contained elements, free memory and destroy the set itself.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if <tt class="docutils literal">value_type</tt> has a trivial destructor or the set is empty;
linear in <tt class="docutils literal">size()</tt> otherwise.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id66">
<h3><a class="toc-backref" href="#id473">Size and Capacity</a></h3>
<div class="section" id="id67">
<h4><a class="toc-backref" href="#id474"><tt class="docutils literal">empty ()</tt></a></h4>
<pre class="literal-block">
bool  empty ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the set is empty, i.e. if <tt class="docutils literal">size () == 0</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id68">
<h4><a class="toc-backref" href="#id475"><tt class="docutils literal">size ()</tt></a></h4>
<pre class="literal-block">
size_type  size ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of elements in the set.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id69">
<h4><a class="toc-backref" href="#id476"><tt class="docutils literal">max_size ()</tt></a></h4>
<pre class="literal-block">
size_type  max_size ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The largest size this set could ever have.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id70">
<h4><a class="toc-backref" href="#id477"><tt class="docutils literal">bucket_count ()</tt></a></h4>
<pre class="literal-block">
size_type  bucket_count ()  const;
</pre>
<p>Determine the number of buckets in the container.  For sets with allocated bucket array
this is the number of allocated buckets (not including private buckets, if any).  For
empty containers this is the number the container will allocate when needed.  So, the
return value is always non-zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Current number of buckets.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id71">
<h4><a class="toc-backref" href="#id478"><tt class="docutils literal">max_bucket_count ()</tt></a></h4>
<pre class="literal-block">
size_type  max_bucket_count ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The largest number of buckets this set could ever have.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id72">
<h3><a class="toc-backref" href="#id479">Iterators</a></h3>
<div class="section" id="id73">
<h4><a class="toc-backref" href="#id480"><tt class="docutils literal">begin ()</tt></a></h4>
<pre class="literal-block">
iterator        begin ();
const_iterator  begin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the first element in the set, or past-the-end
iterator if the set is empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id74">
<h4><a class="toc-backref" href="#id481"><tt class="docutils literal">cbegin ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cbegin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A constant iterator pointing to the first element in the set, or
past-the-end iterator if the set is empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id75">
<h4><a class="toc-backref" href="#id482"><tt class="docutils literal">end ()</tt></a></h4>
<pre class="literal-block">
iterator        end ();
const_iterator  end ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end iterator for the set.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id76">
<h4><a class="toc-backref" href="#id483"><tt class="docutils literal">cend ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cend ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end iterator for the set.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="rbegin">
<h4><a class="toc-backref" href="#id484"><tt class="docutils literal">rbegin ()</tt></a></h4>
<pre class="literal-block">
reverse_iterator        rbegin ();
const_reverse_iterator  rbegin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A reverse iterator pointing to the first element in the reversed set, or
past-the-end iterator if the set is empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="crbegin">
<h4><a class="toc-backref" href="#id485"><tt class="docutils literal">crbegin ()</tt></a></h4>
<pre class="literal-block">
const_reverse_iterator  crbegin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A constant reverse iterator pointing to the first element in the reversed
set, or past-the-end iterator if the set is empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="rend">
<h4><a class="toc-backref" href="#id486"><tt class="docutils literal">rend ()</tt></a></h4>
<pre class="literal-block">
reverse_iterator        rend ();
const_reverse_iterator  rend ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end reverse iterator for the set.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="crend">
<h4><a class="toc-backref" href="#id487"><tt class="docutils literal">crend ()</tt></a></h4>
<pre class="literal-block">
const_reverse_iterator  crend ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end reverse iterator for the set.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id77">
<h3><a class="toc-backref" href="#id488">Data Lookup</a></h3>
<div class="section" id="front">
<h4><a class="toc-backref" href="#id489"><tt class="docutils literal">front ()</tt></a></h4>
<pre class="literal-block">
reference        front ();
const_reference  front ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The first element in set’s iteration order.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The set must not be empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="back">
<h4><a class="toc-backref" href="#id490"><tt class="docutils literal">back ()</tt></a></h4>
<pre class="literal-block">
reference        back ();
const_reference  back ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The last element in set’s iteration order.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The set must not be empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id78">
<h4><a class="toc-backref" href="#id491"><tt class="docutils literal">find (key)</tt></a></h4>
<pre class="literal-block">
iterator        find (const key_type&amp; key);
const_iterator  find (const key_type&amp; key)  const;
</pre>
<p>Find an element with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to matching element or <tt class="docutils literal">end()</tt> if there’s no such
element.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id79">
<h4><a class="toc-backref" href="#id492"><tt class="docutils literal">count (key)</tt></a></h4>
<pre class="literal-block">
size_type  count (const key_type&amp; key)  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of elements with given <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a set return value is always 0 or 1.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id80">
<h4><a class="toc-backref" href="#id493"><tt class="docutils literal">equal_range (key)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, iterator&gt;              equal_range (const key_type&amp; key);
std::pair &lt;const_iterator, const_iterator&gt;  equal_range (const key_type&amp; key)  const;
</pre>
<p>Determine the range consisting of all elements with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair <tt class="docutils literal">P</tt> such that <tt class="docutils literal">[P.first, P.second)</tt> is the range consisting
all elements with given <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a set such a range always contains 0 or 1 element.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id81">
<h3><a class="toc-backref" href="#id494">Container Modifications</a></h3>
<p>Note that all <tt class="docutils literal">insert()</tt> variants (as well as similar <tt class="docutils literal">push_front()</tt> and
<tt class="docutils literal">push_back()</tt>) invalidate iterators while all <tt class="docutils literal">erase()</tt> (as well as similar
<tt class="docutils literal">pop_front()</tt> and <tt class="docutils literal">pop_back()</tt>) don’t.</p>
<div class="section" id="push-front-value">
<h4><a class="toc-backref" href="#id495"><tt class="docutils literal">push_front (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_front (const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the set unless the set already contains an equal one.  If
the <tt class="docutils literal">value</tt> is inserted, it will be the first in set’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_front (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="push-back-value">
<h4><a class="toc-backref" href="#id496"><tt class="docutils literal">push_back (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_back (const value_type&amp; value);
</pre>
<p>Exactly the same as <tt class="docutils literal">insert (value)</tt>.</p>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_back (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="id82">
<h4><a class="toc-backref" href="#id497"><tt class="docutils literal">insert (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the set unless the set already contains an equal one.  If
the <tt class="docutils literal">value</tt> is inserted, it will be the last in set’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="insert-before-value">
<h4><a class="toc-backref" href="#id498"><tt class="docutils literal">insert (before, value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (const_iterator before, const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the set unless the set already contains an equal one.  If
the <tt class="docutils literal">value</tt> is inserted, it will immediately precede element pointed to by the given
iterator in iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (const_iterator before, value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">This function has the same arguments as hint-insertion in <tt class="docutils literal">closed_hash_set</tt>, but a
different return type and arguably different meaning.  This was deemed acceptable,
since hint-insertion is hardly useful and is provided mainly for compatibility with
<tt class="docutils literal">unordered_set</tt>.  Since <tt class="docutils literal">linked_hash_set</tt> is not a direct analogue of that class,
compatibility is not a major issue here.</p>
</div>
</div>
<div class="section" id="id83">
<h4><a class="toc-backref" href="#id499"><tt class="docutils literal">template insert (first, last)</tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
void  insert (InputIterator first, InputIterator last);
</pre>
<p>Insert all values in the range <tt class="docutils literal">[first, last)</tt> into the set.  Values that are equal to
any already contained are effectively ignored.  This is equivalent to calling single-item
<tt class="docutils literal">insert()</tt> on each value in the range, but using this function might be more efficient.
Inserted elements in the range will be the last in set’s iteration order; their relative
precedence will be the same as in <tt class="docutils literal">[first, last)</tt> range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="template-insert-before-first-last">
<h4><a class="toc-backref" href="#id500"><tt class="docutils literal">template insert (before, first, last)</tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
void  insert (const_iterator before, InputIterator first, InputIterator last);
</pre>
<p>Insert all values in the range <tt class="docutils literal">[first, last)</tt> into the set.  Values that are equal to
any already contained are effectively ignored.  This is equivalent to calling single-item
<tt class="docutils literal">insert()</tt> on each value in the range, but using this function might be more efficient.
Inserted elements in the range will immediately precede element pointed to by the given
iterator in iteration order; their relative precedence will be the same as in <tt class="docutils literal">[first,
last)</tt> range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id84">
<h4><a class="toc-backref" href="#id501"><tt class="docutils literal">insert ({ <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
void  insert (std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Insert given <tt class="docutils literal">values</tt> into the set.  Values that are equal to any already contained are
effectively ignored.  This is equivalent to calling single-item <tt class="docutils literal">insert()</tt> on each value
in the list, but using this function might be more efficient.  Inserted elements will be
the last in set’s iteration order; their relative precedence will be the same as in the
list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="insert-before-values">
<h4><a class="toc-backref" href="#id502"><tt class="docutils literal">insert (before, { <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
void  insert (const_iterator before, std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Insert given <tt class="docutils literal">values</tt> into the set.  Values that are equal to any already contained are
effectively ignored.  This is equivalent to calling single-item <tt class="docutils literal">insert()</tt> on each value
in the list, but using this function might be more efficient.  Inserted elements will
immediately precede element pointed to by the given iterator in iteration order; their
relative precedence will be the same as in the list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id85">
<h4><a class="toc-backref" href="#id503"><tt class="docutils literal">template emplace (args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace (Args&amp;&amp;... args);
</pre>
<p>Insert a <tt class="docutils literal">value_type</tt> object constructed with given arguments into the set unless the
set already contains an equal one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">Purpose of this function in the standard <tt class="docutils literal">unordered_set</tt> is to avoid moving or
copying the constructed object.  Unfortunately, this is impossible to achieve with
closed hashing, so in <tt class="docutils literal">linked_hash_set</tt> this is not faster than simple <tt class="docutils literal">insert()</tt>.
This function exists mostly for compatibility reasons.</p>
</div>
</div>
<div class="section" id="template-emplace-before-before-args">
<h4><a class="toc-backref" href="#id504"><tt class="docutils literal">template emplace_before (before, args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace_before (const_iterator before, Args&amp;&amp;... args);
</pre>
<p>Insert a <tt class="docutils literal">value_type</tt> object constructed with given arguments into the set unless the
set already contains an equal one.  If the object is inserted, it will immediately precede
element pointed to by the given iterator in iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">Purpose of similar functions in the standard <tt class="docutils literal">unordered_set</tt> is to avoid moving or
copying the constructed object.  Unfortunately, this is impossible to achieve with
closed hashing, so in <tt class="docutils literal">linked_hash_set</tt> this is not faster than simple <tt class="docutils literal">insert()</tt>.
This function exists mostly for compatibility reasons.</p>
</div>
</div>
<div class="section" id="id86">
<h4><a class="toc-backref" href="#id505"><tt class="docutils literal">template emplace_hint (hint, args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace (const_iterator hint, Args&amp;&amp;... args);
</pre>
<p>Currently <tt class="docutils literal">hint</tt> is simply ignored and effect is the same as <tt class="docutils literal"><span class="pre">emplace&nbsp;(args)</span></tt>.</p>
</div>
<div class="section" id="pop-front">
<h4><a class="toc-backref" href="#id506"><tt class="docutils literal">pop_front ()</tt></a></h4>
<pre class="literal-block">
void  pop_front ();
</pre>
<p>Erase the first element in the set’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The set must not be empty.  Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pop-back">
<h4><a class="toc-backref" href="#id507"><tt class="docutils literal">pop_back ()</tt></a></h4>
<pre class="literal-block">
void  pop_back ();
</pre>
<p>Erase the last element in the set’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The set must not be empty.  Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id87">
<h4><a class="toc-backref" href="#id508"><tt class="docutils literal">erase (key)</tt></a></h4>
<pre class="literal-block">
size_type  erase (const key_type&amp; key);
</pre>
<p>Erase an element with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of erased elements; might be zero.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a set return value is always 0 or 1.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id88">
<h4><a class="toc-backref" href="#id509"><tt class="docutils literal">erase (iterator)</tt></a></h4>
<pre class="literal-block">
iterator  erase (const_iterator position);
</pre>
<p>Erase the element at given <tt class="docutils literal">position</tt> and return an iterator to the next one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the next element or <tt class="docutils literal">end()</tt> if there’s no next
element.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id89">
<h4><a class="toc-backref" href="#id510"><tt class="docutils literal">quick_erase (iterator)</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.4</p>
</div>
<pre class="literal-block">
void  quick_erase (const_iterator position);
</pre>
<p>Erase the element at given <tt class="docutils literal">position</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">This function mainly exists for compatibility with <tt class="docutils literal">closed_hash_set</tt>.  In a linked
set <tt class="docutils literal"><span class="pre">erase&nbsp;(iterator)</span></tt> function is of constant complexity, so <tt class="docutils literal">quick_erase()</tt>
doesn’t have any particular advantage.</p>
</div>
</div>
<div class="section" id="id90">
<h4><a class="toc-backref" href="#id511"><tt class="docutils literal">erase (first, last)</tt></a></h4>
<pre class="literal-block">
iterator  erase (const_iterator first, const_iterator last);
</pre>
<p>Erase a range of elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the element following the range — i.e. <tt class="docutils literal">last</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in distance between <tt class="docutils literal">first</tt> and <tt class="docutils literal">last</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id91">
<h4><a class="toc-backref" href="#id512"><tt class="docutils literal">clear ()</tt></a></h4>
<pre class="literal-block">
void  clear ();
</pre>
<p>Erase all elements in the set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in <tt class="docutils literal">bucket_count()</tt>.  Constant for empty sets.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id92">
<h4><a class="toc-backref" href="#id513"><tt class="docutils literal">swap (that)</tt></a></h4>
<pre class="literal-block">
void  swap (linked_hash_set&amp; that);
</pre>
<p>Swap contents (elements), hash function, equality predicates and maximum load factors
between two sets.  Allocators are not swapped.  Iteration orders are swapped along with
elements: after swapping, <tt class="docutils literal">this</tt> set will yield the same sequence of elements as
<tt class="docutils literal">that</tt> set did before, and vice versa.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Only if allocators are different: exceptions thrown by (either set’s) hash
function, equality predicates or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">If the allocators are equal the function never throws. Otherwise strong
exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if the allocators are equal.  Otherwise the same as copying the
two sets, see the copy constructor.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="iteration-order-modifications">
<h3><a class="toc-backref" href="#id514">Iteration Order Modifications</a></h3>
<p>Note that since container is a <em>set</em>, below operations don’t change its equality.
I.e. the container after the operation will always be equal (as defined by <tt class="docutils literal">operator==</tt>)
to itself before the operation.</p>
<p>These functions never invalidate iterators or throw anything.</p>
<div class="section" id="relink-before-element">
<h4><a class="toc-backref" href="#id515"><tt class="docutils literal">relink (before, element)</tt></a></h4>
<pre class="literal-block">
void  relink (const_iterator before, iterator element);
</pre>
<p>Make given <tt class="docutils literal">element</tt> (second argument) directly precede <tt class="docutils literal">before</tt> (first argument) in
the container’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">It is allowed to pass equal iterators, in which case nothing will be done
(an element cannot precede itself).</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="reverse">
<h4><a class="toc-backref" href="#id516"><tt class="docutils literal">reverse ()</tt></a></h4>
<pre class="literal-block">
void  reverse ();
</pre>
<p>Reverse the order in which container’s elements are iterated.  I.e. formerly first element
becomes the last, second element becomes second to last and so on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sort-compare">
<h4><a class="toc-backref" href="#id517"><tt class="docutils literal">sort ([compare])</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.6</p>
</div>
<pre class="literal-block">
void  sort ();

template &lt;typename Compare&gt;
void  sort (Compare compare);
</pre>
<p>Reorder set elements so that they are iterated in ascending order.  In the first version
elements are compared using <tt class="docutils literal">operator&lt;</tt>, in the second case — with the <tt class="docutils literal">compare</tt>
function object.  Sorting is guaranteed to be stable.  Comparison doesn’t have to be
consistent with set’s equality predicate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the used comparison function.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Basic exception safety: if an exception is thrown, order of elements is
undefined.  Does not invalidate iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">O(<tt class="docutils literal">n log n</tt>) where <tt class="docutils literal">n</tt> is the set size.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id93">
<h3><a class="toc-backref" href="#id518">Hashing Policy</a></h3>
<div class="section" id="id94">
<h4><a class="toc-backref" href="#id519"><tt class="docutils literal">load_factor ()</tt></a></h4>
<pre class="literal-block">
float  load_factor ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Current load factor of the container.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id95">
<h4><a class="toc-backref" href="#id520"><tt class="docutils literal">max_load_factor ()</tt></a></h4>
<pre class="literal-block">
float  max_load_factor ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Maximum allowed load factor of the container.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id96">
<h4><a class="toc-backref" href="#id521"><tt class="docutils literal">max_load_factor (set_to)</tt></a></h4>
<pre class="literal-block">
void  max_load_factor (float set_to);
</pre>
<p>Change maximum load factor of the set.  If the new maximum is smaller than the current
load factor, the set is rehashed to reduce the load.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators if a rehash is trigerred.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if <tt class="docutils literal"><span class="pre">load_factor()&nbsp;&lt;&nbsp;set_to</span></tt>; otherwise same as for <tt class="docutils literal">rehash()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id97">
<h4><a class="toc-backref" href="#id522"><tt class="docutils literal">rehash (num_buckets)</tt></a></h4>
<pre class="literal-block">
void  rehash (size_type num_buckets);
</pre>
<p>Change bucket count to given value, if possible.  Implementation can alter <tt class="docutils literal">num_buckets</tt>
as needed to have load factor small enough as well as for internal reasons.  In
particular, it is legal to specify zero as number of buckets: this will be replaced with
the smallest number that keeps load below the allowed maximum.  Finally, it sometimes
makes sense (for performance) to rehash to the same number of buckets as before to “clean”
the container after erasing elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">bucket_count()</tt>; worst case quadratic in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id98">
<h4><a class="toc-backref" href="#id523"><tt class="docutils literal">reserve (num_elements)</tt></a></h4>
<pre class="literal-block">
void  reserve (size_type num_elements);
</pre>
<p>Rehash the table in such a way that it will not be rehashed anymore if size doesn’t exceed
given value and no <tt class="docutils literal">erase()</tt>-like functions are used.  This is exactly identical to:</p>
<pre class="literal-block">
set.rehash (std::ceil (num_elements / set.max_load_factor ()));
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for <tt class="docutils literal">rehash()</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id99">
<h3><a class="toc-backref" href="#id524">Construction Parameter Queries</a></h3>
<div class="section" id="id100">
<h4><a class="toc-backref" href="#id525"><tt class="docutils literal">hash_function ()</tt></a></h4>
<pre class="literal-block">
hasher  hash_function ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Set’s hash function object.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id101">
<h4><a class="toc-backref" href="#id526"><tt class="docutils literal">key_eq ()</tt></a></h4>
<pre class="literal-block">
key_equal  key_eq ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Set’s equality predicate object.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id102">
<h4><a class="toc-backref" href="#id527"><tt class="docutils literal">get_allocator ()</tt></a></h4>
<pre class="literal-block">
allocator_type  get_allocator ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Set’s allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id103">
<h3><a class="toc-backref" href="#id528">Non-Member Functions</a></h3>
<div class="section" id="id104">
<h4><a class="toc-backref" href="#id529"><tt class="docutils literal">operator== (set1, set2)</tt></a></h4>
<pre class="literal-block">
operator== (const linked_hash_set &lt;...&gt;&amp; set1, const linked_hash_set &lt;...&gt;&amp; set2);
</pre>
<p>Compare the elements of the two sets.  Remember that despite being linked, containers are
still <em>sets</em>, i.e. iteration order is irrelevant to container equality.</p>
<p>See also more generic <tt class="docutils literal">operator==</tt> in <a class="reference internal" href="#cross-container-functions">Cross-Container Functions</a> section.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the sets are equal, i.e. contain the same elements.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Result does <em>not</em> depend on either sets’ iteration order.  It is undefined
if the sets’ equality predicates are not equivalent.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">size()</tt>; worst case is quadratic in <tt class="docutils literal">size()</tt>.
Optimizations: constant for comparing a set with itself or comparing sets of
different sizes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id105">
<h4><a class="toc-backref" href="#id530"><tt class="docutils literal">operator!= (set1, set2)</tt></a></h4>
<pre class="literal-block">
operator!= (const linked_hash_set &lt;...&gt;&amp; set1, const linked_hash_set &lt;...&gt;&amp; set2);
</pre>
<p>See <tt class="docutils literal">operator==</tt> for details.</p>
</div>
<div class="section" id="id106">
<h4><a class="toc-backref" href="#id531"><tt class="docutils literal">swap (set1, set2)</tt></a></h4>
<pre class="literal-block">
void  swap (linked_hash_set &lt;...&gt;&amp; set1, linked_hash_set &lt;...&gt;&amp; set2);
</pre>
<p>Effect is identical to <tt class="docutils literal">set1.swap (set2)</tt>.  See the function for details.</p>
</div>
<div class="section" id="id107">
<h4><a class="toc-backref" href="#id532"><tt class="docutils literal"><span class="pre">boost::serialization::serialize</span> (archive, set, version)</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.6</p>
</div>
<p>A function defined in a separate header <tt class="docutils literal"><span class="pre">&lt;mct/hash-set-serialization.hpp&gt;</span></tt>.  Allows to
serialize and unserialize linked hash sets using common Boost.Serialization mechanisms.</p>
</div>
</div>
</div>
<div class="section" id="linked-hash-map">
<h2><a class="toc-backref" href="#id339"><tt class="docutils literal">linked_hash_map</tt></a></h2>
<p>A fast unordered container mapping unique keys to arbitrary values and providing stable
iteration order.</p>
<p>Iterators are invalidated by all <tt class="docutils literal">insert()</tt> variants, <tt class="docutils literal">operator[]</tt>, setter function
<tt class="docutils literal"><span class="pre">max_load_factor&nbsp;(float)</span></tt> and <tt class="docutils literal">rehash()</tt>.  All member and associated non-member
functions except <tt class="docutils literal">sort()</tt> provide strong exception safety.</p>
<p>Note that <tt class="docutils literal">linked_hash_map</tt> is <em>not a sequence</em> despite having many functions of the
latter.</p>
<div class="important">
<p class="first admonition-title">Important</p>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.4</p>
</div>
<p class="last">On many platforms maximum number of buckets in a <tt class="docutils literal">linked_hash_map</tt> is substantially
less than would fit in memory, though still at least <em>1 billion</em>.  If that’s important
to you, read about <a class="reference internal" href="#huge-linked-hash-tables">huge linked hash tables</a>.</p>
</div>
<div class="contents local topic" id="id108">
<ul class="simple">
<li><a class="reference internal" href="#id109" id="id533">Definition</a></li>
<li><a class="reference internal" href="#id110" id="id534">Type Members</a></li>
<li><a class="reference internal" href="#id111" id="id535">Constructors, Copy and Destructor</a><ul>
<li><a class="reference internal" href="#id112" id="id536"><tt class="docutils literal">linked_hash_map <span class="pre">([...])</span></tt></a></li>
<li><a class="reference internal" href="#linked-hash-map-that" id="id537"><tt class="docutils literal">linked_hash_map (that)</tt></a></li>
<li><a class="reference internal" href="#linked-hash-map-that-allocator" id="id538"><tt class="docutils literal">linked_hash_map (that, allocator)</tt></a></li>
<li><a class="reference internal" href="#template-linked-hash-map-first-last" id="id539"><tt class="docutils literal">template linked_hash_map (first, last, <span class="pre">[...])</span></tt></a></li>
<li><a class="reference internal" href="#linked-hash-map-values" id="id540"><tt class="docutils literal">linked_hash_map ({ <span class="pre">values...</span> }, <span class="pre">[...])</span></tt></a></li>
<li><a class="reference internal" href="#id113" id="id541"><tt class="docutils literal">operator= (that)</tt></a></li>
<li><a class="reference internal" href="#id114" id="id542"><tt class="docutils literal">operator= ({ <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#id115" id="id543"><tt class="docutils literal">~linked_hash_map ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id116" id="id544">Size and Capacity</a><ul>
<li><a class="reference internal" href="#id117" id="id545"><tt class="docutils literal">empty ()</tt></a></li>
<li><a class="reference internal" href="#id118" id="id546"><tt class="docutils literal">size ()</tt></a></li>
<li><a class="reference internal" href="#id119" id="id547"><tt class="docutils literal">max_size ()</tt></a></li>
<li><a class="reference internal" href="#id120" id="id548"><tt class="docutils literal">bucket_count ()</tt></a></li>
<li><a class="reference internal" href="#id121" id="id549"><tt class="docutils literal">max_bucket_count ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id122" id="id550">Iterators</a><ul>
<li><a class="reference internal" href="#id123" id="id551"><tt class="docutils literal">begin ()</tt></a></li>
<li><a class="reference internal" href="#id124" id="id552"><tt class="docutils literal">cbegin ()</tt></a></li>
<li><a class="reference internal" href="#id125" id="id553"><tt class="docutils literal">end ()</tt></a></li>
<li><a class="reference internal" href="#id126" id="id554"><tt class="docutils literal">cend ()</tt></a></li>
<li><a class="reference internal" href="#id127" id="id555"><tt class="docutils literal">rbegin ()</tt></a></li>
<li><a class="reference internal" href="#id128" id="id556"><tt class="docutils literal">crbegin ()</tt></a></li>
<li><a class="reference internal" href="#id129" id="id557"><tt class="docutils literal">rend ()</tt></a></li>
<li><a class="reference internal" href="#id130" id="id558"><tt class="docutils literal">crend ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id131" id="id559">Data Lookup</a><ul>
<li><a class="reference internal" href="#id132" id="id560"><tt class="docutils literal">front ()</tt></a></li>
<li><a class="reference internal" href="#id133" id="id561"><tt class="docutils literal">back ()</tt></a></li>
<li><a class="reference internal" href="#id134" id="id562"><tt class="docutils literal">find (key)</tt></a></li>
<li><a class="reference internal" href="#id135" id="id563"><tt class="docutils literal">count (key)</tt></a></li>
<li><a class="reference internal" href="#id136" id="id564"><tt class="docutils literal">equal_range (key)</tt></a></li>
<li><a class="reference internal" href="#id137" id="id565"><tt class="docutils literal">operator[] (key)</tt></a></li>
<li><a class="reference internal" href="#id138" id="id566"><tt class="docutils literal">at (key)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id139" id="id567">Container Modifications</a><ul>
<li><a class="reference internal" href="#id140" id="id568"><tt class="docutils literal">push_front (value)</tt></a></li>
<li><a class="reference internal" href="#id141" id="id569"><tt class="docutils literal">push_back (value)</tt></a></li>
<li><a class="reference internal" href="#id142" id="id570"><tt class="docutils literal">insert (value)</tt></a></li>
<li><a class="reference internal" href="#id143" id="id571"><tt class="docutils literal">insert (before, value)</tt></a></li>
<li><a class="reference internal" href="#id144" id="id572"><tt class="docutils literal">template insert (first, last)</tt></a></li>
<li><a class="reference internal" href="#id145" id="id573"><tt class="docutils literal">template insert (before, first, last)</tt></a></li>
<li><a class="reference internal" href="#id146" id="id574"><tt class="docutils literal">insert ({ <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#id147" id="id575"><tt class="docutils literal">insert (before, { <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#id148" id="id576"><tt class="docutils literal">template emplace (args)</tt></a></li>
<li><a class="reference internal" href="#id149" id="id577"><tt class="docutils literal">template emplace_before (before, args)</tt></a></li>
<li><a class="reference internal" href="#id150" id="id578"><tt class="docutils literal">template emplace_hint (hint, args)</tt></a></li>
<li><a class="reference internal" href="#id151" id="id579"><tt class="docutils literal">pop_front ()</tt></a></li>
<li><a class="reference internal" href="#id152" id="id580"><tt class="docutils literal">pop_back ()</tt></a></li>
<li><a class="reference internal" href="#id153" id="id581"><tt class="docutils literal">erase (key)</tt></a></li>
<li><a class="reference internal" href="#id154" id="id582"><tt class="docutils literal">erase (iterator)</tt></a></li>
<li><a class="reference internal" href="#id155" id="id583"><tt class="docutils literal">quick_erase (iterator)</tt></a></li>
<li><a class="reference internal" href="#id156" id="id584"><tt class="docutils literal">erase (first, last)</tt></a></li>
<li><a class="reference internal" href="#id157" id="id585"><tt class="docutils literal">clear ()</tt></a></li>
<li><a class="reference internal" href="#id158" id="id586"><tt class="docutils literal">swap (that)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id159" id="id587">Iteration Order Modifications</a><ul>
<li><a class="reference internal" href="#id160" id="id588"><tt class="docutils literal">relink (before, element)</tt></a></li>
<li><a class="reference internal" href="#id161" id="id589"><tt class="docutils literal">reverse ()</tt></a></li>
<li><a class="reference internal" href="#id162" id="id590"><tt class="docutils literal">sort ([compare])</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id163" id="id591">Hashing Policy</a><ul>
<li><a class="reference internal" href="#id164" id="id592"><tt class="docutils literal">load_factor ()</tt></a></li>
<li><a class="reference internal" href="#id165" id="id593"><tt class="docutils literal">max_load_factor ()</tt></a></li>
<li><a class="reference internal" href="#id166" id="id594"><tt class="docutils literal">max_load_factor (set_to)</tt></a></li>
<li><a class="reference internal" href="#id167" id="id595"><tt class="docutils literal">rehash (num_buckets)</tt></a></li>
<li><a class="reference internal" href="#id168" id="id596"><tt class="docutils literal">reserve (num_elements)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id169" id="id597">Construction Parameter Queries</a><ul>
<li><a class="reference internal" href="#id170" id="id598"><tt class="docutils literal">hash_function ()</tt></a></li>
<li><a class="reference internal" href="#id171" id="id599"><tt class="docutils literal">key_eq ()</tt></a></li>
<li><a class="reference internal" href="#id172" id="id600"><tt class="docutils literal">get_allocator ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id173" id="id601">Non-Member Functions</a><ul>
<li><a class="reference internal" href="#id174" id="id602"><tt class="docutils literal">operator== (map1, map2)</tt></a></li>
<li><a class="reference internal" href="#id175" id="id603"><tt class="docutils literal">operator!= (map1, map2)</tt></a></li>
<li><a class="reference internal" href="#id176" id="id604"><tt class="docutils literal">swap (map1, map2)</tt></a></li>
<li><a class="reference internal" href="#id177" id="id605"><tt class="docutils literal"><span class="pre">boost::serialization::serialize</span> (archive, map, version)</tt></a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id109">
<h3><a class="toc-backref" href="#id533">Definition</a></h3>
<p>The class is defined in header <tt class="docutils literal"><span class="pre">&lt;mct/hash-map.hpp&gt;</span></tt>:</p>
<pre class="literal-block">
template &lt;typename Key,
          typename Mapped,
          typename Hash        = hash &lt;Key&gt;,
          typename Equal       = std::equal_to &lt;Key&gt;,
          typename Allocator   = std::allocator &lt;std::pair &lt;const Key, Mapped&gt; &gt;,
          bool     keep_hashes = false&gt;
class linked_hash_map;
</pre>
<p>Template parameters:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">Key</tt>:</th><td class="field-body">The map’s key type; must be assignable and copy-constructible</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Mapped</tt>:</th><td class="field-body">The type keys are mapped to; must be copy-constructible</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Hash</tt>:</th><td class="field-body">A unary function object type that hashes <tt class="docutils literal">Key</tt> objects and returns an
<tt class="docutils literal"><span class="pre">std::size_t</span></tt> hash; copy constructor <em>must not</em> throw, see <a class="reference internal" href="#common-note-above">common note above</a></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Equal</tt>:</th><td class="field-body">A binary function object type used to compare objects of type <tt class="docutils literal">Key</tt>, i.e.
equality predicate; copy constructor <em>must not</em> throw, see <a class="reference internal" href="#common-note-above">common note above</a></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Allocator</tt>:</th><td class="field-body">Allocator for type <tt class="docutils literal"><span class="pre">std::pair</span> &lt;const Key, Mapped&gt;</tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">keep_hashes</tt>:</th><td class="field-body">Flag that determines whether the map keeps hashes of individual contained keys
(i.e. doesn’t recompute them); see <a class="reference internal" href="#flag-description-above">flag description above</a> for details</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="id110">
<h3><a class="toc-backref" href="#id534">Type Members</a></h3>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">key_type</tt>:</th><td class="field-body">The map’s key type</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">mapped_type</tt>:</th><td class="field-body">The type keys are mapped to</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">value_type</tt>:</th><td class="field-body">The map’s value type; always <tt class="docutils literal"><span class="pre">std::pair&nbsp;&lt;const&nbsp;key_type,&nbsp;mapped_type&gt;</span></tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">hasher</tt>:</th><td class="field-body">The type of the hash function object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">key_equal</tt>:</th><td class="field-body">The type of equality function object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">allocator_type</tt>:</th><td class="field-body">The type of allocator object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">iterator</tt>:</th><td class="field-body">A bidirectional iterator type capable of navigating the map; note that the
iterator is not mutable because <tt class="docutils literal">first</tt> member of the pair it points to cannot
be modified</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_iterator</tt>:</th><td class="field-body">A constant bidirectional iterator; similar to <tt class="docutils literal">iterator</tt> except that values it
points to are immutable</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">reverse_iterator</tt>:</th><td class="field-body">A bidirectional iterator type that can be used to iterate the map backwards;
<tt class="docutils literal">first</tt> member of the pair it points to cannot be modified.</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_reverse_iterator</tt>:</th><td class="field-body">A constant bidirectional iterator type that can be used to iterate the set
backwards.</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">pointer</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_pointer</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">reference</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_reference</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">size_type</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">difference_type</tt>:</th><td class="field-body">Standard container type members; mostly interesting for meta-programming needs</td>
</tr>
</tbody>
</table>
</blockquote>
<p>In linked tables, increment and decrement operators of the iterators have constant
complexity.</p>
</div>
<div class="section" id="id111">
<h3><a class="toc-backref" href="#id535">Constructors, Copy and Destructor</a></h3>
<div class="section" id="id112">
<h4><a class="toc-backref" href="#id536"><tt class="docutils literal">linked_hash_map <span class="pre">([...])</span></tt></a></h4>
<pre class="literal-block">
linked_hash_map (size_type              num_buckets = 0,
                 const hasher&amp;          hash        = hasher (),
                 const key_equal&amp;       equal       = key_equal (),
                 const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create an empty map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant, but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt> on first
element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="linked-hash-map-that">
<h4><a class="toc-backref" href="#id537"><tt class="docutils literal">linked_hash_map (that)</tt></a></h4>
<pre class="literal-block">
linked_hash_map (const linked_hash_map&amp; that);
</pre>
<p>Create a new map as a copy of another.  Copies contained elements, hash function object,
equality predicate, allocator and maximum load factor of the other container.  Iteration
order in the copy is the same as in <tt class="docutils literal">that</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">that.size()</tt>; worst case is quadratic in
<tt class="docutils literal">that.size()</tt>.  If <tt class="docutils literal">that</tt> is empty: constant, but with certain
allocation linear in <tt class="docutils literal">bucket_count()</tt> on first element insertion.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
linked_hash_map (linked_hash_map&amp;&amp; that);
</pre>
<p>The same as copy constructor, except that the second map is left in undefined state.
Unlike the copy constructor, this never throws.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="linked-hash-map-that-allocator">
<h4><a class="toc-backref" href="#id538"><tt class="docutils literal">linked_hash_map (that, allocator)</tt></a></h4>
<pre class="literal-block">
linked_hash_map (const linked_hash_map&amp; that, const allocator_type&amp; allocator);
</pre>
<p>Similar to the copy constructor, but uses explicitly specified <tt class="docutils literal">allocator</tt> instead of
copying it from <tt class="docutils literal">that</tt> container.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for copy constructor.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="template-linked-hash-map-first-last">
<h4><a class="toc-backref" href="#id539"><tt class="docutils literal">template linked_hash_map (first, last, <span class="pre">[...])</span></tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
linked_hash_map (InputIterator          first,
                 InputIterator          last,
                 size_type              num_buckets = 0,
                 const hasher&amp;          hash        = hasher (),
                 const key_equal&amp;       equal       = key_equal (),
                 const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create a map containing all elements in the range <tt class="docutils literal">[first, last)</tt>.  Elements with
duplicate keys in the range are effectively ignored: only the first is inserted into the
new map.  Iteration order of the map matches <tt class="docutils literal">[first, last)</tt> except for elements with
duplicate keys: as only the first copy is added to the map, it is also the only visited
during iteration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in maximum of range size and <tt class="docutils literal">num_buckets</tt>; worst case
quadratic in range size.  If <tt class="docutils literal"><span class="pre">first&nbsp;==&nbsp;last</span></tt>: constant, but with certain
allocation linear in <tt class="docutils literal">bucket_count()</tt> on first element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="linked-hash-map-values">
<h4><a class="toc-backref" href="#id540"><tt class="docutils literal">linked_hash_map ({ <span class="pre">values...</span> }, <span class="pre">[...])</span></tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This constructor is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
linked_hash_map (std::initializer_list &lt;value_type&gt; initializer,
                 size_type              num_buckets = 0,
                 const hasher&amp;          hash        = hasher (),
                 const key_equal&amp;       equal       = key_equal (),
                 const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create a map containing all elements from <tt class="docutils literal">initializer</tt> list.  Elements with duplicate
keys are effectively ignored.  Iteration order of other elements in the new map is the
same as in the list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in maximum of number of <tt class="docutils literal">values</tt> and <tt class="docutils literal">num_buckets</tt>;
worst case quadratic in number of <tt class="docutils literal">values</tt>.  If the initializer list is
empty: constant, but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt>
on first element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id113">
<h4><a class="toc-backref" href="#id541"><tt class="docutils literal">operator= (that)</tt></a></h4>
<pre class="literal-block">
linked_hash_map&amp;  operator= (const linked_hash_map&amp; that);
</pre>
<p>Erase current map contents and replace it with contents of another map.  This replaces
hash function, equality predicate and maximum load factor, but not the allocator.  After
assignment, iteration order of the two maps is the same.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.
Also see <a class="reference internal" href="#common-note-above">common note above</a>.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for destructor plus copy constructor.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
linked_hash_map&amp;  operator= (linked_hash_map&amp;&amp; that);
</pre>
<p>The same as copy assignment, except that the second map is left in undefined state.
If allocators of the two maps are equal this version doesn’t throw.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for destructor if allocators of this and <tt class="docutils literal">that</tt> maps are equal;
otherwise same as for destructor plus copy constructor.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id114">
<h4><a class="toc-backref" href="#id542"><tt class="docutils literal">operator= ({ <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This assignment is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
linked_hash_map&amp;  operator= (std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Erase current map contents and replace it with values from the <tt class="docutils literal">initializers</tt>.  Elements
with duplicate keys in the list are effectively ignored.  Iteration order of other
elements matches their relative order in the initialization list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in number of values; worst case quadratic in number of
values.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id115">
<h4><a class="toc-backref" href="#id543"><tt class="docutils literal">~linked_hash_map ()</tt></a></h4>
<p>Destroy all contained elements, free memory and destroy the map itself.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if <tt class="docutils literal">value_type</tt> has a trivial destructor or the map is empty;
linear in <tt class="docutils literal">size()</tt> otherwise.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id116">
<h3><a class="toc-backref" href="#id544">Size and Capacity</a></h3>
<div class="section" id="id117">
<h4><a class="toc-backref" href="#id545"><tt class="docutils literal">empty ()</tt></a></h4>
<pre class="literal-block">
bool  empty ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the map is empty, i.e. if <tt class="docutils literal">size () == 0</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id118">
<h4><a class="toc-backref" href="#id546"><tt class="docutils literal">size ()</tt></a></h4>
<pre class="literal-block">
size_type  size ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of elements in the map.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id119">
<h4><a class="toc-backref" href="#id547"><tt class="docutils literal">max_size ()</tt></a></h4>
<pre class="literal-block">
size_type  max_size ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The largest size this map could ever have.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id120">
<h4><a class="toc-backref" href="#id548"><tt class="docutils literal">bucket_count ()</tt></a></h4>
<pre class="literal-block">
size_type  bucket_count ()  const;
</pre>
<p>Determine the number of buckets in the container.  For maps with allocated bucket array
this is the number of allocated buckets (not including private buckets, if any).  For
empty containers this is the number the container will allocate when needed.  So, the
return value is always non-zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Current number of buckets.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id121">
<h4><a class="toc-backref" href="#id549"><tt class="docutils literal">max_bucket_count ()</tt></a></h4>
<pre class="literal-block">
size_type  max_bucket_count ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The largest number of buckets this map could ever have.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id122">
<h3><a class="toc-backref" href="#id550">Iterators</a></h3>
<div class="section" id="id123">
<h4><a class="toc-backref" href="#id551"><tt class="docutils literal">begin ()</tt></a></h4>
<pre class="literal-block">
iterator        begin ();
const_iterator  begin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the first element in the map, or past-the-end
iterator if the map is empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id124">
<h4><a class="toc-backref" href="#id552"><tt class="docutils literal">cbegin ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cbegin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A constant iterator pointing to the first element in the map, or
past-the-end iterator if the map is empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id125">
<h4><a class="toc-backref" href="#id553"><tt class="docutils literal">end ()</tt></a></h4>
<pre class="literal-block">
iterator        end ();
const_iterator  end ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end iterator for the map.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id126">
<h4><a class="toc-backref" href="#id554"><tt class="docutils literal">cend ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cend ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end iterator for the map.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id127">
<h4><a class="toc-backref" href="#id555"><tt class="docutils literal">rbegin ()</tt></a></h4>
<pre class="literal-block">
reverse_iterator        rbegin ();
const_reverse_iterator  rbegin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A reverse iterator pointing to the first element in the reversed map, or
past-the-end iterator if the map is empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id128">
<h4><a class="toc-backref" href="#id556"><tt class="docutils literal">crbegin ()</tt></a></h4>
<pre class="literal-block">
const_reverse_iterator  crbegin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A constant reverse iterator pointing to the first element in the reversed
map, or past-the-end iterator if the map is empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id129">
<h4><a class="toc-backref" href="#id557"><tt class="docutils literal">rend ()</tt></a></h4>
<pre class="literal-block">
reverse_iterator        rend ();
const_reverse_iterator  rend ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end reverse iterator for the map.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id130">
<h4><a class="toc-backref" href="#id558"><tt class="docutils literal">crend ()</tt></a></h4>
<pre class="literal-block">
const_reverse_iterator  crend ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end reverse iterator for the map.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id131">
<h3><a class="toc-backref" href="#id559">Data Lookup</a></h3>
<div class="section" id="id132">
<h4><a class="toc-backref" href="#id560"><tt class="docutils literal">front ()</tt></a></h4>
<pre class="literal-block">
reference        front ();
const_reference  front ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The first element in map’s iteration order.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The map must not be empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id133">
<h4><a class="toc-backref" href="#id561"><tt class="docutils literal">back ()</tt></a></h4>
<pre class="literal-block">
reference        back ();
const_reference  back ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The last element in map’s iteration order.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The map must not be empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id134">
<h4><a class="toc-backref" href="#id562"><tt class="docutils literal">find (key)</tt></a></h4>
<pre class="literal-block">
iterator        find (const key_type&amp; key);
const_iterator  find (const key_type&amp; key)  const;
</pre>
<p>Find an element with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to matching element or <tt class="docutils literal">end()</tt> if there’s no such
element.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id135">
<h4><a class="toc-backref" href="#id563"><tt class="docutils literal">count (key)</tt></a></h4>
<pre class="literal-block">
size_type  count (const key_type&amp; key)  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of elements with given <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a map return value is always 0 or 1.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id136">
<h4><a class="toc-backref" href="#id564"><tt class="docutils literal">equal_range (key)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, iterator&gt;              equal_range (const key_type&amp; key);
std::pair &lt;const_iterator, const_iterator&gt;  equal_range (const key_type&amp; key)  const;
</pre>
<p>Determine the range consisting of all elements with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair <tt class="docutils literal">P</tt> such that <tt class="docutils literal">[P.first, P.second)</tt> is the range consisting
all elements with given <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a map such a range always contains 0 or 1 element.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id137">
<h4><a class="toc-backref" href="#id565"><tt class="docutils literal">operator[] (key)</tt></a></h4>
<pre class="literal-block">
mapped_type&amp;  operator[] (const key_type&amp; key);
</pre>
<p>Find the object given <tt class="docutils literal">key</tt> is mapped to, or else insert a new association with
default-constructed <tt class="docutils literal">mapped_type</tt>.  If insertion happens, new element will be the last
in the map’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A reference to a pre-existed or newly inserted object associated with
<tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators if a new association is created.  Strong exception
safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id138">
<h4><a class="toc-backref" href="#id566"><tt class="docutils literal">at (key)</tt></a></h4>
<pre class="literal-block">
mapped_type&amp;        at (const key_type&amp; key);
const mapped_type&amp;  at (const key_type&amp; key)  const;
</pre>
<p>Find the element with given <tt class="docutils literal">key</tt> and assert its presence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A reference to the pre-existed object associated with <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body"><tt class="docutils literal"><span class="pre">std::out_of_range</span></tt> if there is no element with given <tt class="docutils literal">key</tt> (the
assertion fails).  Additionally, exceptions thrown by the hash function or
equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id139">
<h3><a class="toc-backref" href="#id567">Container Modifications</a></h3>
<p>Note that all <tt class="docutils literal">insert()</tt> variants (as well as similar <tt class="docutils literal">push_front()</tt> and
<tt class="docutils literal">push_back()</tt>) invalidate iterators while all <tt class="docutils literal">erase()</tt> (as well as similar
<tt class="docutils literal">pop_front()</tt> and <tt class="docutils literal">pop_back()</tt>) don’t.</p>
<div class="section" id="id140">
<h4><a class="toc-backref" href="#id568"><tt class="docutils literal">push_front (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_front (const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the map unless the map already contains one with equal
key.  If the <tt class="docutils literal">value</tt> is inserted, it will be the first in map’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_front (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="id141">
<h4><a class="toc-backref" href="#id569"><tt class="docutils literal">push_back (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_back (const value_type&amp; value);
</pre>
<p>Exactly the same as <tt class="docutils literal">insert (value)</tt>.</p>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_back (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="id142">
<h4><a class="toc-backref" href="#id570"><tt class="docutils literal">insert (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the map unless the map already contains one with equal
key.  If the <tt class="docutils literal">value</tt> is inserted, it will be the last in map’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or pre-existed with equal key)
element and a flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="id143">
<h4><a class="toc-backref" href="#id571"><tt class="docutils literal">insert (before, value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (const_iterator before, const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the map unless the map already contains one with equal
key.  If the <tt class="docutils literal">value</tt> is inserted, it will immediately precede element pointed to by the
given iterator in iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (const_iterator before, value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">This function has the same arguments as hint-insertion in <tt class="docutils literal">closed_hash_map</tt>, but a
different return type and arguably different meaning.  This was deemed acceptable,
since hint-insertion is hardly useful and is provided mainly for compatibility with
<tt class="docutils literal">unordered_map</tt>.  Since <tt class="docutils literal">linked_hash_map</tt> is not a direct analogue of that class,
compatibility is not a major issue here.</p>
</div>
</div>
<div class="section" id="id144">
<h4><a class="toc-backref" href="#id572"><tt class="docutils literal">template insert (first, last)</tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
void  insert (InputIterator first, InputIterator last);
</pre>
<p>Insert all values in the range <tt class="docutils literal">[first, last)</tt> into the map. Values with keys that are
equal to any already contained are effectively ignored. This is equivalent to calling
single-item <tt class="docutils literal">insert()</tt> on each value in the range, but using this function might be more
efficient.  Inserted elements in the range will be the last in map’s iteration order;
their relative precedence will be the same as in <tt class="docutils literal">[first, last)</tt> range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id145">
<h4><a class="toc-backref" href="#id573"><tt class="docutils literal">template insert (before, first, last)</tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
void  insert (const_iterator before, InputIterator first, InputIterator last);
</pre>
<p>Insert all values in the range <tt class="docutils literal">[first, last)</tt> into the map. Values with keys that are
equal to any already contained are effectively ignored. This is equivalent to calling
single-item <tt class="docutils literal">insert()</tt> on each value in the range, but using this function might be more
efficient.  Inserted elements in the range will immediately precede element pointed to by
the given iterator in iteration order; their relative precedence will be the same as in
<tt class="docutils literal">[first, last)</tt> range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id146">
<h4><a class="toc-backref" href="#id574"><tt class="docutils literal">insert ({ <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
void  insert (std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Insert given <tt class="docutils literal">values</tt> into the map.  Values with keys that are equal to any already
contained are effectively ignored.  This is equivalent to calling single-item <tt class="docutils literal">insert()</tt>
on each value in the list, but using this function might be more efficient.  Inserted
elements will be the last in map’s iteration order; their relative precedence will be the
same as in the list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id147">
<h4><a class="toc-backref" href="#id575"><tt class="docutils literal">insert (before, { <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
void  insert (const_iterator before, std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Insert given <tt class="docutils literal">values</tt> into the map.  Values with keys that are equal to any already
contained are effectively ignored.  This is equivalent to calling single-item <tt class="docutils literal">insert()</tt>
on each value in the list, but using this function might be more efficient.  Inserted
elements will immediately precede element pointed to by the given iterator in iteration
order; their relative precedence will be the same as in the list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id148">
<h4><a class="toc-backref" href="#id576"><tt class="docutils literal">template emplace (args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace (Args&amp;&amp;... args);
</pre>
<p>Insert a <tt class="docutils literal">value_type</tt> object constructed with given arguments into the map unless the
map already contains one with equal key.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">Purpose of this function in the standard <tt class="docutils literal">unordered_map</tt> is to avoid moving or
copying the constructed object.  Unfortunately, this is impossible to achieve with
closed hashing, so in <tt class="docutils literal">linked_hash_map</tt> this is not faster than simple <tt class="docutils literal">insert()</tt>.
This function exists mostly for compatibility reasons.</p>
</div>
</div>
<div class="section" id="id149">
<h4><a class="toc-backref" href="#id577"><tt class="docutils literal">template emplace_before (before, args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace_before (const_iterator before, Args&amp;&amp;... args);
</pre>
<p>Insert a <tt class="docutils literal">value_type</tt> object constructed with given arguments into the map unless the
map already contains one with equal key.  If the object is inserted, it will immediately
precede element pointed to by the given iterator in iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">Purpose of similar functions in the standard <tt class="docutils literal">unordered_map</tt> is to avoid moving or
copying the constructed object.  Unfortunately, this is impossible to achieve with
closed hashing, so in <tt class="docutils literal">linked_hash_map</tt> this is not faster than simple <tt class="docutils literal">insert()</tt>.
This function exists mostly for compatibility reasons.</p>
</div>
</div>
<div class="section" id="id150">
<h4><a class="toc-backref" href="#id578"><tt class="docutils literal">template emplace_hint (hint, args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace (const_iterator hint, Args&amp;&amp;... args);
</pre>
<p>Currently <tt class="docutils literal">hint</tt> is simply ignored and effect is the same as <tt class="docutils literal"><span class="pre">emplace&nbsp;(args)</span></tt>.</p>
</div>
<div class="section" id="id151">
<h4><a class="toc-backref" href="#id579"><tt class="docutils literal">pop_front ()</tt></a></h4>
<pre class="literal-block">
void  pop_front ();
</pre>
<p>Erase the first element in the map’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The map must not be empty.  Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id152">
<h4><a class="toc-backref" href="#id580"><tt class="docutils literal">pop_back ()</tt></a></h4>
<pre class="literal-block">
void  pop_back ();
</pre>
<p>Erase the last element in the map’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The map must not be empty.  Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id153">
<h4><a class="toc-backref" href="#id581"><tt class="docutils literal">erase (key)</tt></a></h4>
<pre class="literal-block">
size_type  erase (const key_type&amp; key);
</pre>
<p>Erase an element with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of erased elements; might be zero.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a map return value is always 0 or 1.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id154">
<h4><a class="toc-backref" href="#id582"><tt class="docutils literal">erase (iterator)</tt></a></h4>
<pre class="literal-block">
iterator  erase (const_iterator position);
</pre>
<p>Erase the element at given <tt class="docutils literal">position</tt> and return an iterator to the next one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the next element or <tt class="docutils literal">end()</tt> if there’s no next
element.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id155">
<h4><a class="toc-backref" href="#id583"><tt class="docutils literal">quick_erase (iterator)</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.4</p>
</div>
<pre class="literal-block">
void  quick_erase (const_iterator position);
</pre>
<p>Erase the element at given <tt class="docutils literal">position</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">This function mainly exists for compatibility with <tt class="docutils literal">closed_hash_map</tt>.  In a linked
map <tt class="docutils literal"><span class="pre">erase&nbsp;(iterator)</span></tt> function is of constant complexity, so <tt class="docutils literal">quick_erase()</tt>
doesn’t have any particular advantage.</p>
</div>
</div>
<div class="section" id="id156">
<h4><a class="toc-backref" href="#id584"><tt class="docutils literal">erase (first, last)</tt></a></h4>
<pre class="literal-block">
iterator  erase (const_iterator first, const_iterator last);
</pre>
<p>Erase a range of elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the element following the range — i.e. <tt class="docutils literal">last</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in distance between <tt class="docutils literal">first</tt> and <tt class="docutils literal">last</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id157">
<h4><a class="toc-backref" href="#id585"><tt class="docutils literal">clear ()</tt></a></h4>
<pre class="literal-block">
void  clear ();
</pre>
<p>Erase all elements in the map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in <tt class="docutils literal">bucket_count()</tt>.  Constant for empty maps.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id158">
<h4><a class="toc-backref" href="#id586"><tt class="docutils literal">swap (that)</tt></a></h4>
<pre class="literal-block">
void  swap (linked_hash_map&amp; that);
</pre>
<p>Swap contents (elements), hash function, equality predicates and maximum load factors
between two maps.  Allocators are not swapped.  Iteration orders are swapped along with
elements: after swapping, <tt class="docutils literal">this</tt> map will yield the same sequence of elements as
<tt class="docutils literal">that</tt> map did before, and vice versa.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Only if allocators are different: exceptions thrown by (either map’s) hash
function, equality predicates or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">If the allocators are equal the function never throws. Otherwise strong
exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if the allocators are equal.  Otherwise the same as copying the
two maps, see the copy constructor.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id159">
<h3><a class="toc-backref" href="#id587">Iteration Order Modifications</a></h3>
<p>Note that since container is a <em>map</em>, below operations don’t change its equality.
I.e. the container after the operation will always be equal (as defined by <tt class="docutils literal">operator==</tt>)
to itself before the operation.</p>
<p>These functions never invalidate iterators or throw anything.</p>
<div class="section" id="id160">
<h4><a class="toc-backref" href="#id588"><tt class="docutils literal">relink (before, element)</tt></a></h4>
<pre class="literal-block">
void  relink (const_iterator before, iterator element);
</pre>
<p>Make given <tt class="docutils literal">element</tt> (second argument) directly precede <tt class="docutils literal">before</tt> (first argument) in
the container’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">It is allowed to pass equal iterators, in which case nothing will be done
(an element cannot precede itself).</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id161">
<h4><a class="toc-backref" href="#id589"><tt class="docutils literal">reverse ()</tt></a></h4>
<pre class="literal-block">
void  reverse ();
</pre>
<p>Reverse the order in which container’s elements are iterated.  I.e. formerly first element
becomes the last, second element becomes second to last and so on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id162">
<h4><a class="toc-backref" href="#id590"><tt class="docutils literal">sort ([compare])</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.6</p>
</div>
<pre class="literal-block">
void  sort ();

template &lt;typename Compare&gt;
void  sort (Compare compare);
</pre>
<p>Reorder map elements so that they are iterated in ascending order.  In the first version
elements are compared using <tt class="docutils literal">operator&lt;</tt> on their keys, in the second case — with the
<tt class="docutils literal">compare</tt> function object.  Sorting is guaranteed to be stable.  Comparison doesn’t have
to be consistent with map’s equality predicate; in particular, <tt class="docutils literal">compare</tt> may completely
ignore key part and compare the “mapped” part of elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the used comparison function.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Basic exception safety: if an exception is thrown, order of elements is
undefined.  Does not invalidate iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">O(<tt class="docutils literal">n log n</tt>) where <tt class="docutils literal">n</tt> is the map size.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id163">
<h3><a class="toc-backref" href="#id591">Hashing Policy</a></h3>
<div class="section" id="id164">
<h4><a class="toc-backref" href="#id592"><tt class="docutils literal">load_factor ()</tt></a></h4>
<pre class="literal-block">
float  load_factor ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Current load factor of the container.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id165">
<h4><a class="toc-backref" href="#id593"><tt class="docutils literal">max_load_factor ()</tt></a></h4>
<pre class="literal-block">
float  max_load_factor ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Maximum allowed load factor of the container.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id166">
<h4><a class="toc-backref" href="#id594"><tt class="docutils literal">max_load_factor (set_to)</tt></a></h4>
<pre class="literal-block">
void  max_load_factor (float set_to);
</pre>
<p>Change maximum load factor of the map.  If the new maximum is smaller than the current
load factor, the map is rehashed to reduce the load.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators if a rehash is trigerred.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if <tt class="docutils literal"><span class="pre">load_factor()&nbsp;&lt;&nbsp;set_to</span></tt>; otherwise same as for <tt class="docutils literal">rehash()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id167">
<h4><a class="toc-backref" href="#id595"><tt class="docutils literal">rehash (num_buckets)</tt></a></h4>
<pre class="literal-block">
void  rehash (size_type num_buckets);
</pre>
<p>Change bucket count to given value, if possible.  Implementation can alter <tt class="docutils literal">num_buckets</tt>
as needed to have load factor small enough as well as for internal reasons.  In
particular, it is legal to specify zero as number of buckets: this will be replaced with
the smallest number that keeps load below the allowed maximum.  Finally, it sometimes
makes sense (for performance) to rehash to the same number of buckets as before to “clean”
the container after erasing elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">bucket_count()</tt>; worst case quadratic in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id168">
<h4><a class="toc-backref" href="#id596"><tt class="docutils literal">reserve (num_elements)</tt></a></h4>
<pre class="literal-block">
void  reserve (size_type num_elements);
</pre>
<p>Rehash the table in such a way that it will not be rehashed anymore if size doesn’t exceed
given value and no <tt class="docutils literal">erase()</tt>-like functions are used.  This is exactly identical to:</p>
<pre class="literal-block">
map.rehash (std::ceil (num_elements / map.max_load_factor ()));
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for <tt class="docutils literal">rehash()</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id169">
<h3><a class="toc-backref" href="#id597">Construction Parameter Queries</a></h3>
<div class="section" id="id170">
<h4><a class="toc-backref" href="#id598"><tt class="docutils literal">hash_function ()</tt></a></h4>
<pre class="literal-block">
hasher  hash_function ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Map’s hash function object.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id171">
<h4><a class="toc-backref" href="#id599"><tt class="docutils literal">key_eq ()</tt></a></h4>
<pre class="literal-block">
key_equal  key_eq ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Map’s equality predicate object.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id172">
<h4><a class="toc-backref" href="#id600"><tt class="docutils literal">get_allocator ()</tt></a></h4>
<pre class="literal-block">
allocator_type  get_allocator ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Map’s allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id173">
<h3><a class="toc-backref" href="#id601">Non-Member Functions</a></h3>
<div class="section" id="id174">
<h4><a class="toc-backref" href="#id602"><tt class="docutils literal">operator== (map1, map2)</tt></a></h4>
<pre class="literal-block">
operator== (const linked_hash_map &lt;...&gt;&amp; map1, const linked_hash_map &lt;...&gt;&amp; map2);
</pre>
<p>Compare the elements of the two maps.  Second element components (<tt class="docutils literal">mapped_type</tt>) are
compared with <tt class="docutils literal">operator==</tt>, while the first (<tt class="docutils literal">key_type</tt>) — with the map equality
predicate.  Remember that despite being linked, containers are still <em>maps</em>,
i.e. iteration order is irrelevant to container equality.</p>
<p>See also more generic <tt class="docutils literal">operator==</tt> in <a class="reference internal" href="#cross-container-functions">Cross-Container Functions</a> section.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the maps are equal, i.e. contain the same elements.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Result does <em>not</em> depend on either maps’ iteration order.  It is undefined
if the maps’ equality predicates are not equivalent.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">size()</tt>; worst case is quadratic in <tt class="docutils literal">size()</tt>.
Optimizations: constant for comparing a map with itself or comparing maps of
different sizes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id175">
<h4><a class="toc-backref" href="#id603"><tt class="docutils literal">operator!= (map1, map2)</tt></a></h4>
<pre class="literal-block">
operator!= (const linked_hash_map &lt;...&gt;&amp; map1, const linked_hash_map &lt;...&gt;&amp; map2);
</pre>
<p>See <tt class="docutils literal">operator==</tt> for details.</p>
</div>
<div class="section" id="id176">
<h4><a class="toc-backref" href="#id604"><tt class="docutils literal">swap (map1, map2)</tt></a></h4>
<pre class="literal-block">
void  swap (linked_hash_map &lt;...&gt;&amp; map1, linked_hash_map &lt;...&gt;&amp; map2);
</pre>
<p>Effect is identical to <tt class="docutils literal">map1.swap (map2)</tt>.  See the function for details.</p>
</div>
<div class="section" id="id177">
<h4><a class="toc-backref" href="#id605"><tt class="docutils literal"><span class="pre">boost::serialization::serialize</span> (archive, map, version)</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.6</p>
</div>
<p>A function defined in a separate header <tt class="docutils literal"><span class="pre">&lt;mct/hash-map-serialization.hpp&gt;</span></tt>.  Allows to
serialize and unserialize linked hash maps using common Boost.Serialization mechanisms.</p>
</div>
</div>
</div>
<div class="section" id="forward-hash-set">
<h2><a class="toc-backref" href="#id340"><tt class="docutils literal">forward_hash_set</tt></a></h2>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.2</p>
</div>
<p>A fast unordered container with unique values and stable iteration order.</p>
<div class="important">
<p class="first admonition-title">Important</p>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.4</p>
</div>
<p class="last">On many platforms maximum number of buckets in a <tt class="docutils literal">forward_hash_set</tt> is substantially
less than would fit in memory, though still at least <em>1 billion</em>.  If that’s important
to you, read about <a class="reference internal" href="#huge-forward-hash-tables">huge forward hash tables</a>.</p>
</div>
<div class="contents local topic" id="id178">
<ul class="simple">
<li><a class="reference internal" href="#id179" id="id606">Definition</a></li>
<li><a class="reference internal" href="#id180" id="id607">Type Members</a></li>
<li><a class="reference internal" href="#id181" id="id608">Constructors, Copy and Destructor</a><ul>
<li><a class="reference internal" href="#id182" id="id609"><tt class="docutils literal">forward_hash_set <span class="pre">([...])</span></tt></a></li>
<li><a class="reference internal" href="#forward-hash-set-that" id="id610"><tt class="docutils literal">forward_hash_set (that)</tt></a></li>
<li><a class="reference internal" href="#forward-hash-set-that-allocator" id="id611"><tt class="docutils literal">forward_hash_set (that, allocator)</tt></a></li>
<li><a class="reference internal" href="#template-forward-hash-set-first-last" id="id612"><tt class="docutils literal">template forward_hash_set (first, last, <span class="pre">[...])</span></tt></a></li>
<li><a class="reference internal" href="#forward-hash-set-values" id="id613"><tt class="docutils literal">forward_hash_set ({ <span class="pre">values...</span> }, <span class="pre">[...])</span></tt></a></li>
<li><a class="reference internal" href="#id183" id="id614"><tt class="docutils literal">operator= (that)</tt></a></li>
<li><a class="reference internal" href="#id184" id="id615"><tt class="docutils literal">operator= ({ <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#id185" id="id616"><tt class="docutils literal">~forward_hash_set ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id186" id="id617">Size and Capacity</a><ul>
<li><a class="reference internal" href="#id187" id="id618"><tt class="docutils literal">empty ()</tt></a></li>
<li><a class="reference internal" href="#id188" id="id619"><tt class="docutils literal">size ()</tt></a></li>
<li><a class="reference internal" href="#id189" id="id620"><tt class="docutils literal">max_size ()</tt></a></li>
<li><a class="reference internal" href="#id190" id="id621"><tt class="docutils literal">bucket_count ()</tt></a></li>
<li><a class="reference internal" href="#id191" id="id622"><tt class="docutils literal">max_bucket_count ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id192" id="id623">Iterators</a><ul>
<li><a class="reference internal" href="#id193" id="id624"><tt class="docutils literal">begin ()</tt></a></li>
<li><a class="reference internal" href="#id194" id="id625"><tt class="docutils literal">cbegin ()</tt></a></li>
<li><a class="reference internal" href="#before-begin" id="id626"><tt class="docutils literal">before_begin ()</tt></a></li>
<li><a class="reference internal" href="#cbefore-begin" id="id627"><tt class="docutils literal">cbefore_begin ()</tt></a></li>
<li><a class="reference internal" href="#id195" id="id628"><tt class="docutils literal">end ()</tt></a></li>
<li><a class="reference internal" href="#id196" id="id629"><tt class="docutils literal">cend ()</tt></a></li>
<li><a class="reference internal" href="#before-end" id="id630"><tt class="docutils literal">before_end ()</tt></a></li>
<li><a class="reference internal" href="#cbefore-end" id="id631"><tt class="docutils literal">cbefore_end ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id197" id="id632">Data Lookup</a><ul>
<li><a class="reference internal" href="#id198" id="id633"><tt class="docutils literal">front ()</tt></a></li>
<li><a class="reference internal" href="#id199" id="id634"><tt class="docutils literal">back ()</tt></a></li>
<li><a class="reference internal" href="#id200" id="id635"><tt class="docutils literal">find (key)</tt></a></li>
<li><a class="reference internal" href="#id201" id="id636"><tt class="docutils literal">count (key)</tt></a></li>
<li><a class="reference internal" href="#id202" id="id637"><tt class="docutils literal">equal_range (key)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id203" id="id638">Container Modifications</a><ul>
<li><a class="reference internal" href="#id204" id="id639"><tt class="docutils literal">push_front (value)</tt></a></li>
<li><a class="reference internal" href="#id205" id="id640"><tt class="docutils literal">push_back (value)</tt></a></li>
<li><a class="reference internal" href="#id206" id="id641"><tt class="docutils literal">insert (value)</tt></a></li>
<li><a class="reference internal" href="#insert-after-after-value" id="id642"><tt class="docutils literal">insert_after (after, value)</tt></a></li>
<li><a class="reference internal" href="#id207" id="id643"><tt class="docutils literal">template insert (first, last)</tt></a></li>
<li><a class="reference internal" href="#template-insert-after-after-first-last" id="id644"><tt class="docutils literal">template insert_after (after, first, last)</tt></a></li>
<li><a class="reference internal" href="#id208" id="id645"><tt class="docutils literal">insert ({ <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#insert-after-after-values" id="id646"><tt class="docutils literal">insert_after (after, { <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#id209" id="id647"><tt class="docutils literal">template emplace (args)</tt></a></li>
<li><a class="reference internal" href="#template-emplace-after-after-args" id="id648"><tt class="docutils literal">template emplace_after (after, args)</tt></a></li>
<li><a class="reference internal" href="#id210" id="id649"><tt class="docutils literal">pop_front ()</tt></a></li>
<li><a class="reference internal" href="#erase-after-iterator" id="id650"><tt class="docutils literal">erase_after (iterator)</tt></a></li>
<li><a class="reference internal" href="#erase-after-position-last" id="id651"><tt class="docutils literal">erase_after (position, last)</tt></a></li>
<li><a class="reference internal" href="#id211" id="id652"><tt class="docutils literal">clear ()</tt></a></li>
<li><a class="reference internal" href="#id212" id="id653"><tt class="docutils literal">swap (that)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id213" id="id654">Iteration Order Modifications</a><ul>
<li><a class="reference internal" href="#relink-after-to-after-from-after" id="id655"><tt class="docutils literal">relink_after (to_after, from_after)</tt></a></li>
<li><a class="reference internal" href="#id214" id="id656"><tt class="docutils literal">reverse ()</tt></a></li>
<li><a class="reference internal" href="#id215" id="id657"><tt class="docutils literal">sort ([compare])</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id216" id="id658">Hashing Policy</a><ul>
<li><a class="reference internal" href="#id217" id="id659"><tt class="docutils literal">load_factor ()</tt></a></li>
<li><a class="reference internal" href="#id218" id="id660"><tt class="docutils literal">max_load_factor ()</tt></a></li>
<li><a class="reference internal" href="#id219" id="id661"><tt class="docutils literal">max_load_factor (set_to)</tt></a></li>
<li><a class="reference internal" href="#id220" id="id662"><tt class="docutils literal">rehash (num_buckets)</tt></a></li>
<li><a class="reference internal" href="#id221" id="id663"><tt class="docutils literal">reserve (num_elements)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id222" id="id664">Construction Parameter Queries</a><ul>
<li><a class="reference internal" href="#id223" id="id665"><tt class="docutils literal">hash_function ()</tt></a></li>
<li><a class="reference internal" href="#id224" id="id666"><tt class="docutils literal">key_eq ()</tt></a></li>
<li><a class="reference internal" href="#id225" id="id667"><tt class="docutils literal">get_allocator ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id226" id="id668">Non-Member Functions</a><ul>
<li><a class="reference internal" href="#id227" id="id669"><tt class="docutils literal">operator== (set1, set2)</tt></a></li>
<li><a class="reference internal" href="#id228" id="id670"><tt class="docutils literal">operator!= (set1, set2)</tt></a></li>
<li><a class="reference internal" href="#id229" id="id671"><tt class="docutils literal">swap (set1, set2)</tt></a></li>
<li><a class="reference internal" href="#id230" id="id672"><tt class="docutils literal"><span class="pre">boost::serialization::serialize</span> (archive, set, version)</tt></a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id179">
<h3><a class="toc-backref" href="#id606">Definition</a></h3>
<p>The class is defined in header <tt class="docutils literal"><span class="pre">&lt;mct/hash-set.hpp&gt;</span></tt>:</p>
<pre class="literal-block">
template &lt;typename Value,
          typename Hash        = hash &lt;Value&gt;,
          typename Equal       = std::equal_to &lt;Value&gt;,
          typename Allocator   = std::allocator &lt;Value&gt;,
          bool     keep_hashes = false&gt;
class forward_hash_set;
</pre>
<p>Template parameters:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">Value</tt>:</th><td class="field-body">The set’s value type; must be assignable and copy-constructible</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Hash</tt>:</th><td class="field-body">A unary function object type that hashes <tt class="docutils literal">Value</tt> objects and returns an
<tt class="docutils literal"><span class="pre">std::size_t</span></tt> hash; copy constructor <em>must not</em> throw, see <a class="reference internal" href="#common-note-above">common note above</a></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Equal</tt>:</th><td class="field-body">A binary function object type used to compare objects of type <tt class="docutils literal">Value</tt>, i.e.
equality predicate; copy constructor <em>must not</em> throw, see <a class="reference internal" href="#common-note-above">common note above</a></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Allocator</tt>:</th><td class="field-body">Allocator for type <tt class="docutils literal">Value</tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">keep_hashes</tt>:</th><td class="field-body">Flag that determines whether the set keeps hashes of individual contained values
(i.e. doesn’t recompute them); see <a class="reference internal" href="#flag-description-above">flag description above</a> for details</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="id180">
<h3><a class="toc-backref" href="#id607">Type Members</a></h3>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">key_type</tt>:</th><td class="field-body">The set’s value type (i.e. the same as <tt class="docutils literal">value_type</tt>)</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">value_type</tt>:</th><td class="field-body">The set’s value type</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">hasher</tt>:</th><td class="field-body">The type of the hash function object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">key_equal</tt>:</th><td class="field-body">The type of equality function object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">allocator_type</tt>:</th><td class="field-body">The type of allocator object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">iterator</tt>:</th><td class="field-body">A forward iterator type capable of navigating the set; value it points to cannot
be modified, so this behaves just like <tt class="docutils literal">const_iterator</tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_iterator</tt>:</th><td class="field-body">A constant forward iterator; for sets this behaves exactly as <tt class="docutils literal">iterator</tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">pointer</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_pointer</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">reference</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_reference</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">size_type</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">difference_type</tt>:</th><td class="field-body">Standard container type members; mostly interesting for meta-programming needs</td>
</tr>
</tbody>
</table>
</blockquote>
<p>In forward linked tables, increment operator of the iterators has constant complexity.</p>
</div>
<div class="section" id="id181">
<h3><a class="toc-backref" href="#id608">Constructors, Copy and Destructor</a></h3>
<div class="section" id="id182">
<h4><a class="toc-backref" href="#id609"><tt class="docutils literal">forward_hash_set <span class="pre">([...])</span></tt></a></h4>
<pre class="literal-block">
forward_hash_set (size_type              num_buckets = 0,
                  const hasher&amp;          hash        = hasher (),
                  const key_equal&amp;       equal       = key_equal (),
                  const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create an empty set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant, but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt> on first
element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="forward-hash-set-that">
<h4><a class="toc-backref" href="#id610"><tt class="docutils literal">forward_hash_set (that)</tt></a></h4>
<pre class="literal-block">
forward_hash_set (const forward_hash_set&amp; that);
</pre>
<p>Create a new set as a copy of another.  Copies contained elements, hash function object,
equality predicate, allocator and maximum load factor of the other container.  Iteration
order in the copy is the same as in <tt class="docutils literal">that</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">that.size()</tt>; worst case is quadratic in
<tt class="docutils literal">that.size()</tt>.  If <tt class="docutils literal">that</tt> is empty: constant, but with certain
allocation linear in <tt class="docutils literal">bucket_count()</tt> on first element insertion.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
forward_hash_set (forward_hash_set&amp;&amp; that);
</pre>
<p>The same as copy constructor, except that the second set is left in undefined state.
Unlike the copy constructor, this never throws.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="forward-hash-set-that-allocator">
<h4><a class="toc-backref" href="#id611"><tt class="docutils literal">forward_hash_set (that, allocator)</tt></a></h4>
<pre class="literal-block">
forward_hash_set (const forward_hash_set&amp; that, const allocator_type&amp; allocator);
</pre>
<p>Similar to the copy constructor, but uses explicitly specified <tt class="docutils literal">allocator</tt> instead of
copying it from <tt class="docutils literal">that</tt> container.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for copy constructor.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="template-forward-hash-set-first-last">
<h4><a class="toc-backref" href="#id612"><tt class="docutils literal">template forward_hash_set (first, last, <span class="pre">[...])</span></tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
forward_hash_set (InputIterator          first,
                  InputIterator          last,
                  size_type              num_buckets = 0,
                  const hasher&amp;          hash        = hasher (),
                  const key_equal&amp;       equal       = key_equal (),
                  const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create a set containing all elements in the range <tt class="docutils literal">[first, last)</tt>.  Duplicate elements
in the range are effectively ignored.  Iteration order of the set matches <tt class="docutils literal">[first,
last)</tt> except for duplicate elements: as only the first copy is added to the set, it is
also the only visited during iteration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in maximum of range size and <tt class="docutils literal">num_buckets</tt>; worst case
quadratic in range size.  If <tt class="docutils literal"><span class="pre">first&nbsp;==&nbsp;last</span></tt>: constant, but with certain
allocation linear in <tt class="docutils literal">bucket_count()</tt> on first element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="forward-hash-set-values">
<h4><a class="toc-backref" href="#id613"><tt class="docutils literal">forward_hash_set ({ <span class="pre">values...</span> }, <span class="pre">[...])</span></tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This constructor is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
forward_hash_set (std::initializer_list &lt;value_type&gt; initializer,
                  size_type              num_buckets = 0,
                  const hasher&amp;          hash        = hasher (),
                  const key_equal&amp;       equal       = key_equal (),
                  const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create a set containing all elements from <tt class="docutils literal">initializer</tt> list.  Duplicate elements are
effectively ignored.  Iteration order of other elements in the new set is the same as in
the list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in maximum of number of <tt class="docutils literal">values</tt> and <tt class="docutils literal">num_buckets</tt>;
worst case quadratic in number of <tt class="docutils literal">values</tt>.  If the initializer list is
empty: constant, but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt>
on first element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id183">
<h4><a class="toc-backref" href="#id614"><tt class="docutils literal">operator= (that)</tt></a></h4>
<pre class="literal-block">
forward_hash_set&amp;  operator= (const forward_hash_set&amp; that);
</pre>
<p>Erase current set contents and replace it with contents of another set.  This replaces
hash function, equality predicate and maximum load factor, but not the allocator.  After
assignment, iteration order of the two sets is the same.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.
Also see <a class="reference internal" href="#common-note-above">common note above</a>.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for destructor plus copy constructor.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
forward_hash_set&amp;  operator= (forward_hash_set&amp;&amp; that);
</pre>
<p>The same as copy assignment, except that the second set is left in undefined state.
If allocators of the two sets are equal this version doesn’t throw.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for destructor if allocators of this and <tt class="docutils literal">that</tt> sets are equal;
otherwise same as for destructor plus copy constructor.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id184">
<h4><a class="toc-backref" href="#id615"><tt class="docutils literal">operator= ({ <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This assignment is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
forward_hash_set&amp;  operator= (std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Erase current set contents and replace it with values from the <tt class="docutils literal">initializers</tt>.
Duplicate elements in the list are effectively ignored.  Iteration order of other elements
matches their relative order in the initialization list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in number of values; worst case quadratic in number of
values.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id185">
<h4><a class="toc-backref" href="#id616"><tt class="docutils literal">~forward_hash_set ()</tt></a></h4>
<p>Destroy all contained elements, free memory and destroy the set itself.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if <tt class="docutils literal">value_type</tt> has a trivial destructor or the set is empty;
linear in <tt class="docutils literal">size()</tt> otherwise.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id186">
<h3><a class="toc-backref" href="#id617">Size and Capacity</a></h3>
<div class="section" id="id187">
<h4><a class="toc-backref" href="#id618"><tt class="docutils literal">empty ()</tt></a></h4>
<pre class="literal-block">
bool  empty ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the set is empty, i.e. if <tt class="docutils literal">size () == 0</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id188">
<h4><a class="toc-backref" href="#id619"><tt class="docutils literal">size ()</tt></a></h4>
<pre class="literal-block">
size_type  size ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of elements in the set.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id189">
<h4><a class="toc-backref" href="#id620"><tt class="docutils literal">max_size ()</tt></a></h4>
<pre class="literal-block">
size_type  max_size ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The largest size this set could ever have.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id190">
<h4><a class="toc-backref" href="#id621"><tt class="docutils literal">bucket_count ()</tt></a></h4>
<pre class="literal-block">
size_type  bucket_count ()  const;
</pre>
<p>Determine the number of buckets in the container.  For sets with allocated bucket array
this is the number of allocated buckets (not including private buckets, if any).  For
empty containers this is the number the container will allocate when needed.  So, the
return value is always non-zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Current number of buckets.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id191">
<h4><a class="toc-backref" href="#id622"><tt class="docutils literal">max_bucket_count ()</tt></a></h4>
<pre class="literal-block">
size_type  max_bucket_count ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The largest number of buckets this set could ever have.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id192">
<h3><a class="toc-backref" href="#id623">Iterators</a></h3>
<div class="section" id="id193">
<h4><a class="toc-backref" href="#id624"><tt class="docutils literal">begin ()</tt></a></h4>
<pre class="literal-block">
iterator        begin ();
const_iterator  begin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the first element in the set, or past-the-end
iterator if the set is empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id194">
<h4><a class="toc-backref" href="#id625"><tt class="docutils literal">cbegin ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cbegin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A constant iterator pointing to the first element in the set, or
past-the-end iterator if the set is empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="before-begin">
<h4><a class="toc-backref" href="#id626"><tt class="docutils literal">before_begin ()</tt></a></h4>
<pre class="literal-block">
iterator        before_begin ();
const_iterator  before_begin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A non-dereferencable iterator that, when incremented, is equal to
<tt class="docutils literal">begin()</tt>.  This is useful as an argument to various <tt class="docutils literal">*_after()</tt>
functions.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cbefore-begin">
<h4><a class="toc-backref" href="#id627"><tt class="docutils literal">cbefore_begin ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cbefore_begin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A constant non-dereferencable iterator that, when incremented, is equal to
<tt class="docutils literal">cbegin()</tt>.  This is useful as an argument to various <tt class="docutils literal">*_after()</tt>
functions.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id195">
<h4><a class="toc-backref" href="#id628"><tt class="docutils literal">end ()</tt></a></h4>
<pre class="literal-block">
iterator        end ();
const_iterator  end ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end iterator for the set.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id196">
<h4><a class="toc-backref" href="#id629"><tt class="docutils literal">cend ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cend ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end iterator for the set.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="before-end">
<h4><a class="toc-backref" href="#id630"><tt class="docutils literal">before_end ()</tt></a></h4>
<pre class="literal-block">
iterator        before_end ();
const_iterator  before_end ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator that, when incremented, is equal to <tt class="docutils literal">end()</tt>.  If the set is
not empty, this is an iterator pointing to the last element.  It is useful
as an argument to various <tt class="docutils literal">*_after()</tt> functions.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cbefore-end">
<h4><a class="toc-backref" href="#id631"><tt class="docutils literal">cbefore_end ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cbefore_end ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A constant iterator that, when incremented, is equal to <tt class="docutils literal">cend()</tt>.  If the
set is not empty, this is an iterator pointing to the last element.  It is
useful as an argument to various <tt class="docutils literal">*_after()</tt> functions.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id197">
<h3><a class="toc-backref" href="#id632">Data Lookup</a></h3>
<div class="section" id="id198">
<h4><a class="toc-backref" href="#id633"><tt class="docutils literal">front ()</tt></a></h4>
<pre class="literal-block">
reference        front ();
const_reference  front ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The first element in set’s iteration order.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The set must not be empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id199">
<h4><a class="toc-backref" href="#id634"><tt class="docutils literal">back ()</tt></a></h4>
<pre class="literal-block">
reference        back ();
const_reference  back ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The last element in set’s iteration order.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The set must not be empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id200">
<h4><a class="toc-backref" href="#id635"><tt class="docutils literal">find (key)</tt></a></h4>
<pre class="literal-block">
iterator        find (const key_type&amp; key);
const_iterator  find (const key_type&amp; key)  const;
</pre>
<p>Find an element with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to matching element or <tt class="docutils literal">end()</tt> if there’s no such
element.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id201">
<h4><a class="toc-backref" href="#id636"><tt class="docutils literal">count (key)</tt></a></h4>
<pre class="literal-block">
size_type  count (const key_type&amp; key)  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of elements with given <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a set return value is always 0 or 1.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id202">
<h4><a class="toc-backref" href="#id637"><tt class="docutils literal">equal_range (key)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, iterator&gt;              equal_range (const key_type&amp; key);
std::pair &lt;const_iterator, const_iterator&gt;  equal_range (const key_type&amp; key)  const;
</pre>
<p>Determine the range consisting of all elements with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair <tt class="docutils literal">P</tt> such that <tt class="docutils literal">[P.first, P.second)</tt> is the range consisting
all elements with given <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a set such a range always contains 0 or 1 element.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id203">
<h3><a class="toc-backref" href="#id638">Container Modifications</a></h3>
<p>Note that all <tt class="docutils literal">insert()</tt> variants (as well as similar <tt class="docutils literal">push_front()</tt> and
<tt class="docutils literal">push_back()</tt>) invalidate iterators while all <tt class="docutils literal">erase()</tt> (as well as similar
<tt class="docutils literal">pop_front()</tt>) don’t.</p>
<div class="section" id="id204">
<h4><a class="toc-backref" href="#id639"><tt class="docutils literal">push_front (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_front (const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the set unless the set already contains an equal one.  If
the <tt class="docutils literal">value</tt> is inserted, it will be the first in set’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_front (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="id205">
<h4><a class="toc-backref" href="#id640"><tt class="docutils literal">push_back (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_back (const value_type&amp; value);
</pre>
<p>Exactly the same as <tt class="docutils literal">insert (value)</tt>.</p>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_back (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="id206">
<h4><a class="toc-backref" href="#id641"><tt class="docutils literal">insert (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the set unless the set already contains an equal one.  If
the <tt class="docutils literal">value</tt> is inserted, it will be the last in set’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="insert-after-after-value">
<h4><a class="toc-backref" href="#id642"><tt class="docutils literal">insert_after (after, value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert_after (const_iterator after, const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the set unless the set already contains an equal one.  If
the <tt class="docutils literal">value</tt> is inserted, it will immediately follow element pointed to by the given
iterator in iteration order.  Iterators returned by <tt class="docutils literal">before_begin()</tt> and
<tt class="docutils literal">before_end()</tt> are commonly used for <tt class="docutils literal">after</tt>, but in addition any valid iterator for
the set is allowed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert_after (const_iterator after, value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="id207">
<h4><a class="toc-backref" href="#id643"><tt class="docutils literal">template insert (first, last)</tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
void  insert (InputIterator first, InputIterator last);
</pre>
<p>Insert all values in the range <tt class="docutils literal">[first, last)</tt> into the set.  Values that are equal to
any already contained are effectively ignored.  This is equivalent to calling single-item
<tt class="docutils literal">insert()</tt> on each value in the range, but using this function might be more efficient.
Inserted elements in the range will be the last in set’s iteration order; their relative
precedence will be the same as in <tt class="docutils literal">[first, last)</tt> range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Basic exception safety: if an exception is thrown,
the set contents is as before plus maybe part of contents of the range.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="template-insert-after-after-first-last">
<h4><a class="toc-backref" href="#id644"><tt class="docutils literal">template insert_after (after, first, last)</tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
void  insert_after (const_iterator after, InputIterator first, InputIterator last);
</pre>
<p>Insert all values in the range <tt class="docutils literal">[first, last)</tt> into the set.  Values that are equal to
any already contained are effectively ignored.  This is equivalent to calling single-item
<tt class="docutils literal">insert_after()</tt> on each value in the range, but using this function might be more
efficient.  Inserted elements in the range will immediately follow element pointed to by
the given iterator in iteration order; their relative precedence will be the same as in
<tt class="docutils literal">[first, last)</tt> range.  Iterators returned by <tt class="docutils literal">before_begin()</tt> and <tt class="docutils literal">before_end()</tt>
are commonly used for <tt class="docutils literal">after</tt>, but in addition any valid iterator for the set is
allowed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Basic exception safety: if an exception is thrown,
the set contents is as before plus maybe part of contents of the range.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id208">
<h4><a class="toc-backref" href="#id645"><tt class="docutils literal">insert ({ <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
void  insert (std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Insert given <tt class="docutils literal">values</tt> into the set.  Values that are equal to any already contained are
effectively ignored.  This is equivalent to calling single-item <tt class="docutils literal">insert()</tt> on each value
in the list, but using this function might be more efficient.  Inserted elements will be
the last in set’s iteration order; their relative precedence will be the same as in the
list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Basic exception safety: if an exception is thrown,
the set contents is as before plus maybe part of contents of the initializer
list.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="insert-after-after-values">
<h4><a class="toc-backref" href="#id646"><tt class="docutils literal">insert_after (after, { <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
void  insert_after (const_iterator after, std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Insert given <tt class="docutils literal">values</tt> into the set.  Values that are equal to any already contained are
effectively ignored.  This is equivalent to calling single-item <tt class="docutils literal">insert_after()</tt> on each
value in the list, but using this function might be more efficient.  Inserted elements
will immediately follow element pointed to by the given iterator in iteration order; their
relative precedence will be the same as in the list.  Iterators returned by
<tt class="docutils literal">before_begin()</tt> and <tt class="docutils literal">before_end()</tt> are commonly used for <tt class="docutils literal">after</tt>, but in addition
any valid iterator for the set is allowed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Basic exception safety: if an exception is thrown,
the set contents is as before plus maybe part of contents of the initializer
list.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id209">
<h4><a class="toc-backref" href="#id647"><tt class="docutils literal">template emplace (args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace (Args&amp;&amp;... args);
</pre>
<p>Insert a <tt class="docutils literal">value_type</tt> object constructed with given arguments into the set unless the
set already contains an equal one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">Purpose of similar function in the standard <tt class="docutils literal">unordered_set</tt> is to avoid moving or
copying the constructed object.  Unfortunately, this is impossible to achieve with
closed hashing, so in <tt class="docutils literal">forward_hash_set</tt> this is not faster than simple
<tt class="docutils literal">insert()</tt>.  This function exists mostly for compatibility reasons.</p>
</div>
</div>
<div class="section" id="template-emplace-after-after-args">
<h4><a class="toc-backref" href="#id648"><tt class="docutils literal">template emplace_after (after, args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace_after (const_iterator after, Args&amp;&amp;... args);
</pre>
<p>Insert a <tt class="docutils literal">value_type</tt> object constructed with given arguments into the set unless the
set already contains an equal one.  If the object is inserted, it will immediately follow
element pointed to by the given iterator in iteration order.  Iterators returned by
<tt class="docutils literal">before_begin()</tt> and <tt class="docutils literal">before_end()</tt> are commonly used for <tt class="docutils literal">after</tt>, but in addition
any valid iterator for the set is allowed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">Purpose of similar functions in the standard <tt class="docutils literal">unordered_set</tt> is to avoid moving or
copying the constructed object.  Unfortunately, this is impossible to achieve with
closed hashing, so in <tt class="docutils literal">forward_hash_set</tt> this is not faster than simple
<tt class="docutils literal">insert()</tt>.  This function exists mostly for compatibility reasons.</p>
</div>
</div>
<div class="section" id="id210">
<h4><a class="toc-backref" href="#id649"><tt class="docutils literal">pop_front ()</tt></a></h4>
<pre class="literal-block">
void  pop_front ();
</pre>
<p>Erase the first element in the set’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The set must not be empty.  Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="erase-after-iterator">
<h4><a class="toc-backref" href="#id650"><tt class="docutils literal">erase_after (iterator)</tt></a></h4>
<pre class="literal-block">
void  erase_after (const_iterator position);
</pre>
<p>Erase the element <em>following</em> given <tt class="docutils literal">position</tt>.  Note that in forward hash tables it is
not possible to erase elements by having an iterator pointing to them: you need an
iterator pointing to the previous element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="erase-after-position-last">
<h4><a class="toc-backref" href="#id651"><tt class="docutils literal">erase_after (position, last)</tt></a></h4>
<pre class="literal-block">
void  erase_after (const_iterator position, const_iterator last);
</pre>
<p>Erase a range of elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in distance between <tt class="docutils literal">position</tt> and <tt class="docutils literal">last</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id211">
<h4><a class="toc-backref" href="#id652"><tt class="docutils literal">clear ()</tt></a></h4>
<pre class="literal-block">
void  clear ();
</pre>
<p>Erase all elements in the set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in <tt class="docutils literal">bucket_count()</tt>.  Constant for empty sets.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id212">
<h4><a class="toc-backref" href="#id653"><tt class="docutils literal">swap (that)</tt></a></h4>
<pre class="literal-block">
void  swap (forward_hash_set&amp; that);
</pre>
<p>Swap contents (elements), hash function, equality predicates and maximum load factors
between two sets.  Allocators are not swapped.  Iteration orders are swapped along with
elements: after swapping, <tt class="docutils literal">this</tt> set will yield the same sequence of elements as
<tt class="docutils literal">that</tt> set did before, and vice versa.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Only if allocators are different: exceptions thrown by (either map’s) hash
function, equality predicates or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">If the allocators are equal the function never throws. Otherwise strong
exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if the allocators are equal.  Otherwise the same as copying the
two maps, see the copy constructor.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id213">
<h3><a class="toc-backref" href="#id654">Iteration Order Modifications</a></h3>
<p>Note that since container is a <em>set</em>, below operations don’t change its equality.
I.e. the container after the operation will always be equal (as defined by <tt class="docutils literal">operator==</tt>)
to itself before the operation.</p>
<p>These functions never invalidate iterators or throw anything.</p>
<div class="section" id="relink-after-to-after-from-after">
<h4><a class="toc-backref" href="#id655"><tt class="docutils literal">relink_after (to_after, from_after)</tt></a></h4>
<pre class="literal-block">
void  relink_after (const_iterator to_after, iterator from_after);
</pre>
<p>Relink the element immediately following the second argument iterator after the first
argument iterator.  Both arguments may be <tt class="docutils literal">before_begin()</tt> or some valid iterators,
except that <tt class="docutils literal">from_after</tt> must not be equal to <tt class="docutils literal">before_end()</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">It is allowed to pass equal iterators or try to relink an element after
itself; in both these cases nothing will be done.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id214">
<h4><a class="toc-backref" href="#id656"><tt class="docutils literal">reverse ()</tt></a></h4>
<pre class="literal-block">
void  reverse ();
</pre>
<p>Reverse the order in which container’s elements are iterated.  I.e. formerly first element
becomes the last, second element becomes second to last and so on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id215">
<h4><a class="toc-backref" href="#id657"><tt class="docutils literal">sort ([compare])</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.6</p>
</div>
<pre class="literal-block">
void  sort ();

template &lt;typename Compare&gt;
void  sort (Compare compare);
</pre>
<p>Reorder set elements so that they are iterated in ascending order.  In the first version
elements are compared using <tt class="docutils literal">operator&lt;</tt>, in the second case — with the <tt class="docutils literal">compare</tt>
function object.  Sorting is guaranteed to be stable.  Comparison doesn’t have to be
consistent with set’s equality predicate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the used comparison function.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Basic exception safety: if an exception is thrown, order of elements is
undefined.  Does not invalidate iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">O(<tt class="docutils literal">n log n</tt>) where <tt class="docutils literal">n</tt> is the set size.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id216">
<h3><a class="toc-backref" href="#id658">Hashing Policy</a></h3>
<div class="section" id="id217">
<h4><a class="toc-backref" href="#id659"><tt class="docutils literal">load_factor ()</tt></a></h4>
<pre class="literal-block">
float  load_factor ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Current load factor of the container.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id218">
<h4><a class="toc-backref" href="#id660"><tt class="docutils literal">max_load_factor ()</tt></a></h4>
<pre class="literal-block">
float  max_load_factor ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Maximum allowed load factor of the container.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id219">
<h4><a class="toc-backref" href="#id661"><tt class="docutils literal">max_load_factor (set_to)</tt></a></h4>
<pre class="literal-block">
void  max_load_factor (float set_to);
</pre>
<p>Change maximum load factor of the set.  If the new maximum is smaller than the current
load factor, the set is rehashed to reduce the load.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators if a rehash is trigerred.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if <tt class="docutils literal"><span class="pre">load_factor()&nbsp;&lt;&nbsp;set_to</span></tt>; otherwise same as for <tt class="docutils literal">rehash()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id220">
<h4><a class="toc-backref" href="#id662"><tt class="docutils literal">rehash (num_buckets)</tt></a></h4>
<pre class="literal-block">
void  rehash (size_type num_buckets);
</pre>
<p>Change bucket count to given value, if possible.  Implementation can alter <tt class="docutils literal">num_buckets</tt>
as needed to have load factor small enough as well as for internal reasons.  In
particular, it is legal to specify zero as number of buckets: this will be replaced with
the smallest number that keeps load below the allowed maximum.  Finally, it sometimes
makes sense (for performance) to rehash to the same number of buckets as before to “clean”
the container after erasing elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">bucket_count()</tt>; worst case quadratic in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id221">
<h4><a class="toc-backref" href="#id663"><tt class="docutils literal">reserve (num_elements)</tt></a></h4>
<pre class="literal-block">
void  reserve (size_type num_elements);
</pre>
<p>Rehash the table in such a way that it will not be rehashed anymore if size doesn’t exceed
given value and no <tt class="docutils literal">erase()</tt>-like functions are used.  This is exactly identical to:</p>
<pre class="literal-block">
set.rehash (std::ceil (num_elements / set.max_load_factor ()));
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for <tt class="docutils literal">rehash()</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id222">
<h3><a class="toc-backref" href="#id664">Construction Parameter Queries</a></h3>
<div class="section" id="id223">
<h4><a class="toc-backref" href="#id665"><tt class="docutils literal">hash_function ()</tt></a></h4>
<pre class="literal-block">
hasher  hash_function ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Set’s hash function object.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id224">
<h4><a class="toc-backref" href="#id666"><tt class="docutils literal">key_eq ()</tt></a></h4>
<pre class="literal-block">
key_equal  key_eq ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Set’s equality predicate object.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id225">
<h4><a class="toc-backref" href="#id667"><tt class="docutils literal">get_allocator ()</tt></a></h4>
<pre class="literal-block">
allocator_type  get_allocator ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Set’s allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id226">
<h3><a class="toc-backref" href="#id668">Non-Member Functions</a></h3>
<div class="section" id="id227">
<h4><a class="toc-backref" href="#id669"><tt class="docutils literal">operator== (set1, set2)</tt></a></h4>
<pre class="literal-block">
operator== (const forward_hash_set &lt;...&gt;&amp; set1, const forward_hash_set &lt;...&gt;&amp; set2);
</pre>
<p>Compare the elements of the two sets.  Remember that despite being (singly) linked,
containers are still <em>sets</em>, i.e. iteration order is irrelevant to container equality.</p>
<p>See also more generic <tt class="docutils literal">operator==</tt> in <a class="reference internal" href="#cross-container-functions">Cross-Container Functions</a> section.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the sets are equal, i.e. contain the same elements.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Result does <em>not</em> depend on either sets’ iteration order.  It is undefined
if the sets’ equality predicates are not equivalent.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">size()</tt>; worst case is quadratic in <tt class="docutils literal">size()</tt>.
Optimizations: constant for comparing a set with itself or comparing sets of
different sizes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id228">
<h4><a class="toc-backref" href="#id670"><tt class="docutils literal">operator!= (set1, set2)</tt></a></h4>
<pre class="literal-block">
operator!= (const forward_hash_set &lt;...&gt;&amp; set1, const forward_hash_set &lt;...&gt;&amp; set2);
</pre>
<p>See <tt class="docutils literal">operator==</tt> for details.</p>
</div>
<div class="section" id="id229">
<h4><a class="toc-backref" href="#id671"><tt class="docutils literal">swap (set1, set2)</tt></a></h4>
<pre class="literal-block">
void  swap (forward_hash_set &lt;...&gt;&amp; set1, forward_hash_set &lt;...&gt;&amp; set2);
</pre>
<p>Effect is identical to <tt class="docutils literal">set1.swap (set2)</tt>.  See the function for details.</p>
</div>
<div class="section" id="id230">
<h4><a class="toc-backref" href="#id672"><tt class="docutils literal"><span class="pre">boost::serialization::serialize</span> (archive, set, version)</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.6</p>
</div>
<p>A function defined in a separate header <tt class="docutils literal"><span class="pre">&lt;mct/hash-set-serialization.hpp&gt;</span></tt>.  Allows to
serialize and unserialize forward hash sets using common Boost.Serialization mechanisms.</p>
</div>
</div>
</div>
<div class="section" id="forward-hash-map">
<h2><a class="toc-backref" href="#id341"><tt class="docutils literal">forward_hash_map</tt></a></h2>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.2</p>
</div>
<p>A fast unordered container mapping unique keys to arbitrary values and providing stable
iteration order.</p>
<div class="important">
<p class="first admonition-title">Important</p>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.4</p>
</div>
<p class="last">On many platforms maximum number of buckets in a <tt class="docutils literal">forward_hash_map</tt> is substantially
less than would fit in memory, though still at least <em>1 billion</em>.  If that’s important
to you, read about <a class="reference internal" href="#huge-forward-hash-tables">huge forward hash tables</a>.</p>
</div>
<div class="contents local topic" id="id231">
<ul class="simple">
<li><a class="reference internal" href="#id232" id="id673">Definition</a></li>
<li><a class="reference internal" href="#id233" id="id674">Type Members</a></li>
<li><a class="reference internal" href="#id234" id="id675">Constructors, Copy and Destructor</a><ul>
<li><a class="reference internal" href="#id235" id="id676"><tt class="docutils literal">forward_hash_map <span class="pre">([...])</span></tt></a></li>
<li><a class="reference internal" href="#forward-hash-map-that" id="id677"><tt class="docutils literal">forward_hash_map (that)</tt></a></li>
<li><a class="reference internal" href="#forward-hash-map-that-allocator" id="id678"><tt class="docutils literal">forward_hash_map (that, allocator)</tt></a></li>
<li><a class="reference internal" href="#template-forward-hash-map-first-last" id="id679"><tt class="docutils literal">template forward_hash_map (first, last, <span class="pre">[...])</span></tt></a></li>
<li><a class="reference internal" href="#forward-hash-map-values" id="id680"><tt class="docutils literal">forward_hash_map ({ <span class="pre">values...</span> }, <span class="pre">[...])</span></tt></a></li>
<li><a class="reference internal" href="#id236" id="id681"><tt class="docutils literal">operator= (that)</tt></a></li>
<li><a class="reference internal" href="#id237" id="id682"><tt class="docutils literal">operator= ({ <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#id238" id="id683"><tt class="docutils literal">~forward_hash_map ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id239" id="id684">Size and Capacity</a><ul>
<li><a class="reference internal" href="#id240" id="id685"><tt class="docutils literal">empty ()</tt></a></li>
<li><a class="reference internal" href="#id241" id="id686"><tt class="docutils literal">size ()</tt></a></li>
<li><a class="reference internal" href="#id242" id="id687"><tt class="docutils literal">max_size ()</tt></a></li>
<li><a class="reference internal" href="#id243" id="id688"><tt class="docutils literal">bucket_count ()</tt></a></li>
<li><a class="reference internal" href="#id244" id="id689"><tt class="docutils literal">max_bucket_count ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id245" id="id690">Iterators</a><ul>
<li><a class="reference internal" href="#id246" id="id691"><tt class="docutils literal">begin ()</tt></a></li>
<li><a class="reference internal" href="#id247" id="id692"><tt class="docutils literal">cbegin ()</tt></a></li>
<li><a class="reference internal" href="#id248" id="id693"><tt class="docutils literal">before_begin ()</tt></a></li>
<li><a class="reference internal" href="#id249" id="id694"><tt class="docutils literal">cbefore_begin ()</tt></a></li>
<li><a class="reference internal" href="#id250" id="id695"><tt class="docutils literal">end ()</tt></a></li>
<li><a class="reference internal" href="#id251" id="id696"><tt class="docutils literal">cend ()</tt></a></li>
<li><a class="reference internal" href="#id252" id="id697"><tt class="docutils literal">before_end ()</tt></a></li>
<li><a class="reference internal" href="#id253" id="id698"><tt class="docutils literal">cbefore_end ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id254" id="id699">Data Lookup</a><ul>
<li><a class="reference internal" href="#id255" id="id700"><tt class="docutils literal">front ()</tt></a></li>
<li><a class="reference internal" href="#id256" id="id701"><tt class="docutils literal">back ()</tt></a></li>
<li><a class="reference internal" href="#id257" id="id702"><tt class="docutils literal">find (key)</tt></a></li>
<li><a class="reference internal" href="#id258" id="id703"><tt class="docutils literal">count (key)</tt></a></li>
<li><a class="reference internal" href="#id259" id="id704"><tt class="docutils literal">equal_range (key)</tt></a></li>
<li><a class="reference internal" href="#id260" id="id705"><tt class="docutils literal">operator[] (key)</tt></a></li>
<li><a class="reference internal" href="#id261" id="id706"><tt class="docutils literal">at (key)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id262" id="id707">Container Modifications</a><ul>
<li><a class="reference internal" href="#id263" id="id708"><tt class="docutils literal">push_front (value)</tt></a></li>
<li><a class="reference internal" href="#id264" id="id709"><tt class="docutils literal">push_back (value)</tt></a></li>
<li><a class="reference internal" href="#id265" id="id710"><tt class="docutils literal">insert (value)</tt></a></li>
<li><a class="reference internal" href="#id266" id="id711"><tt class="docutils literal">insert_after (after, value)</tt></a></li>
<li><a class="reference internal" href="#id267" id="id712"><tt class="docutils literal">template insert (first, last)</tt></a></li>
<li><a class="reference internal" href="#id268" id="id713"><tt class="docutils literal">template insert_after (after, first, last)</tt></a></li>
<li><a class="reference internal" href="#id269" id="id714"><tt class="docutils literal">insert ({ <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#id270" id="id715"><tt class="docutils literal">insert_after (after, { <span class="pre">values...</span> })</tt></a></li>
<li><a class="reference internal" href="#id271" id="id716"><tt class="docutils literal">template emplace (args)</tt></a></li>
<li><a class="reference internal" href="#id272" id="id717"><tt class="docutils literal">template emplace_after (after, args)</tt></a></li>
<li><a class="reference internal" href="#id273" id="id718"><tt class="docutils literal">pop_front ()</tt></a></li>
<li><a class="reference internal" href="#id274" id="id719"><tt class="docutils literal">erase_after (iterator)</tt></a></li>
<li><a class="reference internal" href="#id275" id="id720"><tt class="docutils literal">erase_after (position, last)</tt></a></li>
<li><a class="reference internal" href="#id276" id="id721"><tt class="docutils literal">clear ()</tt></a></li>
<li><a class="reference internal" href="#id277" id="id722"><tt class="docutils literal">swap (that)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id278" id="id723">Iteration Order Modifications</a><ul>
<li><a class="reference internal" href="#id279" id="id724"><tt class="docutils literal">relink_after (to_after, from_after)</tt></a></li>
<li><a class="reference internal" href="#id280" id="id725"><tt class="docutils literal">reverse ()</tt></a></li>
<li><a class="reference internal" href="#id281" id="id726"><tt class="docutils literal">sort ([compare])</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id282" id="id727">Hashing Policy</a><ul>
<li><a class="reference internal" href="#id283" id="id728"><tt class="docutils literal">load_factor ()</tt></a></li>
<li><a class="reference internal" href="#id284" id="id729"><tt class="docutils literal">max_load_factor ()</tt></a></li>
<li><a class="reference internal" href="#id285" id="id730"><tt class="docutils literal">max_load_factor (set_to)</tt></a></li>
<li><a class="reference internal" href="#id286" id="id731"><tt class="docutils literal">rehash (num_buckets)</tt></a></li>
<li><a class="reference internal" href="#id287" id="id732"><tt class="docutils literal">reserve (num_elements)</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id288" id="id733">Construction Parameter Queries</a><ul>
<li><a class="reference internal" href="#id289" id="id734"><tt class="docutils literal">hash_function ()</tt></a></li>
<li><a class="reference internal" href="#id290" id="id735"><tt class="docutils literal">key_eq ()</tt></a></li>
<li><a class="reference internal" href="#id291" id="id736"><tt class="docutils literal">get_allocator ()</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id292" id="id737">Non-Member Functions</a><ul>
<li><a class="reference internal" href="#id293" id="id738"><tt class="docutils literal">operator== (map1, map2)</tt></a></li>
<li><a class="reference internal" href="#id294" id="id739"><tt class="docutils literal">operator!= (map1, map2)</tt></a></li>
<li><a class="reference internal" href="#id295" id="id740"><tt class="docutils literal">swap (map1, map2)</tt></a></li>
<li><a class="reference internal" href="#id296" id="id741"><tt class="docutils literal"><span class="pre">boost::serialization::serialize</span> (archive, map, version)</tt></a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id232">
<h3><a class="toc-backref" href="#id673">Definition</a></h3>
<p>The class is defined in header <tt class="docutils literal"><span class="pre">&lt;mct/hash-map.hpp&gt;</span></tt>:</p>
<pre class="literal-block">
template &lt;typename Key,
          typename Mapped,
          typename Hash        = hash &lt;Key&gt;,
          typename Equal       = std::equal_to &lt;Key&gt;,
          typename Allocator   = std::allocator &lt;std::pair &lt;const Key, Mapped&gt; &gt;,
          bool     keep_hashes = false&gt;
class forward_hash_map;
</pre>
<p>Template parameters:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">Key</tt>:</th><td class="field-body">The map’s key type; must be assignable and copy-constructible</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Mapped</tt>:</th><td class="field-body">The type keys are mapped to; must be copy-constructible</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Hash</tt>:</th><td class="field-body">A unary function object type that hashes <tt class="docutils literal">Key</tt> objects and returns an
<tt class="docutils literal"><span class="pre">std::size_t</span></tt> hash; copy constructor <em>must not</em> throw, see <a class="reference internal" href="#common-note-above">common note above</a></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Equal</tt>:</th><td class="field-body">A binary function object type used to compare objects of type <tt class="docutils literal">Key</tt>, i.e.
equality predicate; copy constructor <em>must not</em> throw, see <a class="reference internal" href="#common-note-above">common note above</a></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Allocator</tt>:</th><td class="field-body">Allocator for type <tt class="docutils literal"><span class="pre">std::pair</span> &lt;const Key, Mapped&gt;</tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">keep_hashes</tt>:</th><td class="field-body">Flag that determines whether the map keeps hashes of individual contained keys
(i.e. doesn’t recompute them); see <a class="reference internal" href="#flag-description-above">flag description above</a> for details</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="id233">
<h3><a class="toc-backref" href="#id674">Type Members</a></h3>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">key_type</tt>:</th><td class="field-body">The map’s key type</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">mapped_type</tt>:</th><td class="field-body">The type keys are mapped to</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">value_type</tt>:</th><td class="field-body">The map’s value type; always <tt class="docutils literal"><span class="pre">std::pair&nbsp;&lt;const&nbsp;key_type,&nbsp;mapped_type&gt;</span></tt></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">hasher</tt>:</th><td class="field-body">The type of the hash function object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">key_equal</tt>:</th><td class="field-body">The type of equality function object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">allocator_type</tt>:</th><td class="field-body">The type of allocator object</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">iterator</tt>:</th><td class="field-body">A forward iterator type capable of navigating the map; note that the iterator is
not mutable because <tt class="docutils literal">first</tt> member of the pair it points to cannot be modified</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_iterator</tt>:</th><td class="field-body">A constant forward iterator; similar to <tt class="docutils literal">iterator</tt> except that values it points
to are immutable</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">pointer</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_pointer</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">reference</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">const_reference</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">size_type</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">difference_type</tt>:</th><td class="field-body">Standard container type members; mostly interesting for meta-programming needs</td>
</tr>
</tbody>
</table>
</blockquote>
<p>In forward linked tables, increment operator of the iterators has constant complexity.</p>
</div>
<div class="section" id="id234">
<h3><a class="toc-backref" href="#id675">Constructors, Copy and Destructor</a></h3>
<div class="section" id="id235">
<h4><a class="toc-backref" href="#id676"><tt class="docutils literal">forward_hash_map <span class="pre">([...])</span></tt></a></h4>
<pre class="literal-block">
forward_hash_map (size_type              num_buckets = 0,
                  const hasher&amp;          hash        = hasher (),
                  const key_equal&amp;       equal       = key_equal (),
                  const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create an empty map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant, but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt> on first
element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="forward-hash-map-that">
<h4><a class="toc-backref" href="#id677"><tt class="docutils literal">forward_hash_map (that)</tt></a></h4>
<pre class="literal-block">
forward_hash_map (const forward_hash_map&amp; that);
</pre>
<p>Create a new map as a copy of another.  Copies contained elements, hash function object,
equality predicate, allocator and maximum load factor of the other container.  Iteration
order in the copy is the same as in <tt class="docutils literal">that</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">that.size()</tt>; worst case is quadratic in
<tt class="docutils literal">that.size()</tt>.  If <tt class="docutils literal">that</tt> is empty: constant, but with certain
allocation linear in <tt class="docutils literal">bucket_count()</tt> on first element insertion.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
forward_hash_map (forward_hash_map&amp;&amp; that);
</pre>
<p>The same as copy constructor, except that the second map is left in undefined state.
Unlike the copy constructor, this never throws.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="forward-hash-map-that-allocator">
<h4><a class="toc-backref" href="#id678"><tt class="docutils literal">forward_hash_map (that, allocator)</tt></a></h4>
<pre class="literal-block">
forward_hash_map (const forward_hash_map&amp; that, const allocator_type&amp; allocator);
</pre>
<p>Similar to the copy constructor, but uses explicitly specified <tt class="docutils literal">allocator</tt> instead of
copying it from <tt class="docutils literal">that</tt> container.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for copy constructor.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="template-forward-hash-map-first-last">
<h4><a class="toc-backref" href="#id679"><tt class="docutils literal">template forward_hash_map (first, last, <span class="pre">[...])</span></tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
forward_hash_map (InputIterator          first,
                  InputIterator          last,
                  size_type              num_buckets = 0,
                  const hasher&amp;          hash        = hasher (),
                  const key_equal&amp;       equal       = key_equal (),
                  const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create a map containing all elements in the range <tt class="docutils literal">[first, last)</tt>.  Elements with
duplicate keys in the range are effectively ignored: only the first is inserted into the
new map.  Iteration order of the map matches <tt class="docutils literal">[first, last)</tt> except for elements with
duplicate keys: as only the first copy is added to the map, it is also the only visited
during iteration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in maximum of range size and <tt class="docutils literal">num_buckets</tt>; worst case
quadratic in range size.  If <tt class="docutils literal"><span class="pre">first&nbsp;==&nbsp;last</span></tt>: constant, but with certain
allocation linear in <tt class="docutils literal">bucket_count()</tt> on first element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="forward-hash-map-values">
<h4><a class="toc-backref" href="#id680"><tt class="docutils literal">forward_hash_map ({ <span class="pre">values...</span> }, <span class="pre">[...])</span></tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This constructor is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
forward_hash_map (std::initializer_list &lt;value_type&gt; initializer,
                  size_type              num_buckets = 0,
                  const hasher&amp;          hash        = hasher (),
                  const key_equal&amp;       equal       = key_equal (),
                  const allocator_type&amp;  allocator   = allocator_type ());
</pre>
<p>Create a map containing all elements from <tt class="docutils literal">initializer</tt> list.  Elements with duplicate
keys are effectively ignored.  Iteration order of other elements in the new map is the
same as in the list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in maximum of number of <tt class="docutils literal">values</tt> and <tt class="docutils literal">num_buckets</tt>;
worst case quadratic in number of <tt class="docutils literal">values</tt>.  If the initializer list is
empty: constant, but with certain allocation linear in <tt class="docutils literal">bucket_count()</tt>
on first element insertion.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id236">
<h4><a class="toc-backref" href="#id681"><tt class="docutils literal">operator= (that)</tt></a></h4>
<pre class="literal-block">
forward_hash_map&amp;  operator= (const forward_hash_map&amp; that);
</pre>
<p>Erase current map contents and replace it with contents of another map.  This replaces
hash function, equality predicate and maximum load factor, but not the allocator.  After
assignment, iteration order of the two maps is the same.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.
Also see <a class="reference internal" href="#common-note-above">common note above</a>.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for destructor plus copy constructor.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
forward_hash_map&amp;  operator= (forward_hash_map&amp;&amp; that);
</pre>
<p>The same as copy assignment, except that the second map is left in undefined state.
If allocators of the two maps are equal this version doesn’t throw.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for destructor if allocators of this and <tt class="docutils literal">that</tt> maps are equal;
otherwise same as for destructor plus copy constructor.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id237">
<h4><a class="toc-backref" href="#id682"><tt class="docutils literal">operator= ({ <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This assignment is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
forward_hash_map&amp;  operator= (std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Erase current map contents and replace it with values from the <tt class="docutils literal">initializers</tt>.  Elements
with duplicate keys in the list are effectively ignored.  Iteration order of other
elements matches their relative order in the initialization list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in number of values; worst case quadratic in number of
values.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id238">
<h4><a class="toc-backref" href="#id683"><tt class="docutils literal">~forward_hash_map ()</tt></a></h4>
<p>Destroy all contained elements, free memory and destroy the map itself.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if <tt class="docutils literal">value_type</tt> has a trivial destructor or the map is empty;
linear in <tt class="docutils literal">size()</tt> otherwise.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id239">
<h3><a class="toc-backref" href="#id684">Size and Capacity</a></h3>
<div class="section" id="id240">
<h4><a class="toc-backref" href="#id685"><tt class="docutils literal">empty ()</tt></a></h4>
<pre class="literal-block">
bool  empty ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the map is empty, i.e. if <tt class="docutils literal">size () == 0</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id241">
<h4><a class="toc-backref" href="#id686"><tt class="docutils literal">size ()</tt></a></h4>
<pre class="literal-block">
size_type  size ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of elements in the map.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id242">
<h4><a class="toc-backref" href="#id687"><tt class="docutils literal">max_size ()</tt></a></h4>
<pre class="literal-block">
size_type  max_size ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The largest size this map could ever have.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id243">
<h4><a class="toc-backref" href="#id688"><tt class="docutils literal">bucket_count ()</tt></a></h4>
<pre class="literal-block">
size_type  bucket_count ()  const;
</pre>
<p>Determine the number of buckets in the container.  For maps with allocated bucket array
this is the number of allocated buckets (not including private buckets, if any).  For
empty containers this is the number the container will allocate when needed.  So, the
return value is always non-zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Current number of buckets.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id244">
<h4><a class="toc-backref" href="#id689"><tt class="docutils literal">max_bucket_count ()</tt></a></h4>
<pre class="literal-block">
size_type  max_bucket_count ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The largest number of buckets this map could ever have.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id245">
<h3><a class="toc-backref" href="#id690">Iterators</a></h3>
<div class="section" id="id246">
<h4><a class="toc-backref" href="#id691"><tt class="docutils literal">begin ()</tt></a></h4>
<pre class="literal-block">
iterator        begin ();
const_iterator  begin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to the first element in the map, or past-the-end
iterator if the map is empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id247">
<h4><a class="toc-backref" href="#id692"><tt class="docutils literal">cbegin ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cbegin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A constant iterator pointing to the first element in the map, or
past-the-end iterator if the map is empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id248">
<h4><a class="toc-backref" href="#id693"><tt class="docutils literal">before_begin ()</tt></a></h4>
<pre class="literal-block">
iterator        before_begin ();
const_iterator  before_begin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A non-dereferencable iterator that, when incremented, is equal to
<tt class="docutils literal">begin()</tt>.  This is useful as an argument to various <tt class="docutils literal">*_after()</tt>
functions.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id249">
<h4><a class="toc-backref" href="#id694"><tt class="docutils literal">cbefore_begin ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cbefore_begin ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A constant non-dereferencable iterator that, when incremented, is equal to
<tt class="docutils literal">cbegin()</tt>.  This is useful as an argument to various <tt class="docutils literal">*_after()</tt>
functions.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id250">
<h4><a class="toc-backref" href="#id695"><tt class="docutils literal">end ()</tt></a></h4>
<pre class="literal-block">
iterator        end ();
const_iterator  end ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end iterator for the map.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id251">
<h4><a class="toc-backref" href="#id696"><tt class="docutils literal">cend ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cend ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Past-the-end iterator for the map.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id252">
<h4><a class="toc-backref" href="#id697"><tt class="docutils literal">before_end ()</tt></a></h4>
<pre class="literal-block">
iterator        before_end ();
const_iterator  before_end ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator that, when incremented, is equal to <tt class="docutils literal">end()</tt>.  If the map is
not empty, this is an iterator pointing to the last element.  It is useful
as an argument to various <tt class="docutils literal">*_after()</tt> functions.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id253">
<h4><a class="toc-backref" href="#id698"><tt class="docutils literal">cbefore_end ()</tt></a></h4>
<pre class="literal-block">
const_iterator  cbefore_end ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A constant iterator that, when incremented, is equal to <tt class="docutils literal">cend()</tt>.  If the
map is not empty, this is an iterator pointing to the last element.  It is
useful as an argument to various <tt class="docutils literal">*_after()</tt> functions.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id254">
<h3><a class="toc-backref" href="#id699">Data Lookup</a></h3>
<div class="section" id="id255">
<h4><a class="toc-backref" href="#id700"><tt class="docutils literal">front ()</tt></a></h4>
<pre class="literal-block">
reference        front ();
const_reference  front ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The first element in map’s iteration order.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The map must not be empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id256">
<h4><a class="toc-backref" href="#id701"><tt class="docutils literal">back ()</tt></a></h4>
<pre class="literal-block">
reference        back ();
const_reference  back ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">The last element in map’s iteration order.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The map must not be empty.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id257">
<h4><a class="toc-backref" href="#id702"><tt class="docutils literal">find (key)</tt></a></h4>
<pre class="literal-block">
iterator        find (const key_type&amp; key);
const_iterator  find (const key_type&amp; key)  const;
</pre>
<p>Find an element with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">An iterator pointing to matching element or <tt class="docutils literal">end()</tt> if there’s no such
element.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id258">
<h4><a class="toc-backref" href="#id703"><tt class="docutils literal">count (key)</tt></a></h4>
<pre class="literal-block">
size_type  count (const key_type&amp; key)  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Number of elements with given <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a map return value is always 0 or 1.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id259">
<h4><a class="toc-backref" href="#id704"><tt class="docutils literal">equal_range (key)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, iterator&gt;              equal_range (const key_type&amp; key);
std::pair &lt;const_iterator, const_iterator&gt;  equal_range (const key_type&amp; key)  const;
</pre>
<p>Determine the range consisting of all elements with given <tt class="docutils literal">key</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair <tt class="docutils literal">P</tt> such that <tt class="docutils literal">[P.first, P.second)</tt> is the range consisting
all elements with given <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For a map such a range always contains 0 or 1 element.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id260">
<h4><a class="toc-backref" href="#id705"><tt class="docutils literal">operator[] (key)</tt></a></h4>
<pre class="literal-block">
mapped_type&amp;  operator[] (const key_type&amp; key);
</pre>
<p>Find the object given <tt class="docutils literal">key</tt> is mapped to, or else insert a new association with
default-constructed <tt class="docutils literal">mapped_type</tt>.  If insertion happens, new element will be the last
in the map’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A reference to a pre-existed or newly inserted object associated with
<tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators if a new association is created.  Strong exception
safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id261">
<h4><a class="toc-backref" href="#id706"><tt class="docutils literal">at (key)</tt></a></h4>
<pre class="literal-block">
mapped_type&amp;        at (const key_type&amp; key);
const mapped_type&amp;  at (const key_type&amp; key)  const;
</pre>
<p>Find the element with given <tt class="docutils literal">key</tt> and assert its presence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A reference to the pre-existed object associated with <tt class="docutils literal">key</tt>.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body"><tt class="docutils literal"><span class="pre">std::out_of_range</span></tt> if there is no element with given <tt class="docutils literal">key</tt> (the
assertion fails).  Additionally, exceptions thrown by the hash function or
equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant; worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id262">
<h3><a class="toc-backref" href="#id707">Container Modifications</a></h3>
<p>Note that all <tt class="docutils literal">insert()</tt> variants (as well as similar <tt class="docutils literal">push_front()</tt> and
<tt class="docutils literal">push_back()</tt>) invalidate iterators while all <tt class="docutils literal">erase()</tt> (as well as similar
<tt class="docutils literal">pop_front()</tt>) don’t.</p>
<div class="section" id="id263">
<h4><a class="toc-backref" href="#id708"><tt class="docutils literal">push_front (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_front (const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the map unless the map already contains one with equal
key.  If the <tt class="docutils literal">value</tt> is inserted, it will be the first in map’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_front (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="id264">
<h4><a class="toc-backref" href="#id709"><tt class="docutils literal">push_back (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_back (const value_type&amp; value);
</pre>
<p>Exactly the same as <tt class="docutils literal">insert (value)</tt>.</p>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  push_back (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="id265">
<h4><a class="toc-backref" href="#id710"><tt class="docutils literal">insert (value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the map unless the map already contains one with equal
key.  If the <tt class="docutils literal">value</tt> is inserted, it will be the last in map’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or pre-existed with equal key)
element and a flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert (value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="id266">
<h4><a class="toc-backref" href="#id711"><tt class="docutils literal">insert_after (after, value)</tt></a></h4>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert_after (const_iterator after, const value_type&amp; value);
</pre>
<p>Insert the given <tt class="docutils literal">value</tt> into the map unless the map already contains one with equal
key.  If the <tt class="docutils literal">value</tt> is inserted, it will immediately follow element pointed to by the
given iterator in iteration order.  Iterators returned by <tt class="docutils literal">before_begin()</tt> and
<tt class="docutils literal">before_end()</tt> are commonly used for <tt class="docutils literal">after</tt>, but in addition any valid iterator for
the map is allowed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p>Only on C++0x compilers:</p>
<pre class="literal-block">
std::pair &lt;iterator, bool&gt;  insert_after (const_iterator after, value_type&amp;&amp; value);
</pre>
<p class="last">Insert the <tt class="docutils literal">value</tt> by using <tt class="docutils literal">value_type</tt>’s move constructor.  Otherwise the same
as above.</p>
</div>
</div>
<div class="section" id="id267">
<h4><a class="toc-backref" href="#id712"><tt class="docutils literal">template insert (first, last)</tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
void  insert (InputIterator first, InputIterator last);
</pre>
<p>Insert all values in the range <tt class="docutils literal">[first, last)</tt> into the map.  Values with keys that are
equal to any already contained are effectively ignored.  This is equivalent to calling
single-item <tt class="docutils literal">insert()</tt> on each value in the range, but using this function might be more
efficient.  Inserted elements in the range will be the last in map’s iteration order;
their relative precedence will be the same as in <tt class="docutils literal">[first, last)</tt> range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Basic exception safety: if an exception is thrown,
the map contents is as before plus maybe part of contents of the range.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id268">
<h4><a class="toc-backref" href="#id713"><tt class="docutils literal">template insert_after (after, first, last)</tt></a></h4>
<pre class="literal-block">
template &lt;typename InputIterator&gt;
void  insert_after (const_iterator after, InputIterator first, InputIterator last);
</pre>
<p>Insert all values in the range <tt class="docutils literal">[first, last)</tt> into the map.  Values with keys that are
equal to any already contained are effectively ignored.  This is equivalent to calling
single-item <tt class="docutils literal">insert_after()</tt> on each value in the range, but using this function might
be more efficient.  Inserted elements in the range will immediately follow element pointed
to by the given iterator in iteration order; their relative precedence will be the same as
in <tt class="docutils literal">[first, last)</tt> range.  Iterators returned by <tt class="docutils literal">before_begin()</tt> and <tt class="docutils literal">before_end()</tt>
are commonly used for <tt class="docutils literal">after</tt>, but in addition any valid iterator for the map is
allowed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Basic exception safety: if an exception is thrown,
the map contents is as before plus maybe part of contents of the range.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id269">
<h4><a class="toc-backref" href="#id714"><tt class="docutils literal">insert ({ <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
void  insert (std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Insert given <tt class="docutils literal">values</tt> into the map.  Values with keys that are equal to any already
contained are effectively ignored.  This is equivalent to calling single-item <tt class="docutils literal">insert()</tt>
on each value in the list, but using this function might be more efficient.  Inserted
elements will be the last in map’s iteration order; their relative precedence will be the
same as in the list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Basic exception safety: if an exception is thrown,
the map contents is as before plus maybe part of contents of the initializer
list.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id270">
<h4><a class="toc-backref" href="#id715"><tt class="docutils literal">insert_after (after, { <span class="pre">values...</span> })</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
void  insert_after (const_iterator after, std::initializer_list &lt;value_type&gt; initializer);
</pre>
<p>Insert given <tt class="docutils literal">values</tt> into the map.  Values with keys that are equal to any already
contained are effectively ignored.  This is equivalent to calling single-item
<tt class="docutils literal">insert_after()</tt> on each value in the list, but using this function might be more
efficient.  Inserted elements will be the last in map’s iteration order; their relative
precedence will be the same as in the list.  Iterators returned by <tt class="docutils literal">before_begin()</tt> and
<tt class="docutils literal">before_end()</tt> are commonly used for <tt class="docutils literal">after</tt>, but in addition any valid iterator for
the map is allowed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Basic exception safety: if an exception is thrown,
the map contents is as before plus maybe part of contents of the initializer
list.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as calling single-item <tt class="docutils literal">insert()</tt> for each value separately.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id271">
<h4><a class="toc-backref" href="#id716"><tt class="docutils literal">template emplace (args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace (Args&amp;&amp;... args);
</pre>
<p>Insert a <tt class="docutils literal">value_type</tt> object constructed with given arguments into the map unless the
map already contains one with equal key.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">Purpose of similar function in the standard <tt class="docutils literal">unordered_map</tt> is to avoid moving or
copying the constructed object.  Unfortunately, this is impossible to achieve with
closed hashing, so in <tt class="docutils literal">forward_hash_map</tt> this is not faster than simple
<tt class="docutils literal">insert()</tt>.  This function exists mostly for compatibility reasons.</p>
</div>
</div>
<div class="section" id="id272">
<h4><a class="toc-backref" href="#id717"><tt class="docutils literal">template emplace_after (after, args)</tt></a></h4>
<div class="admonition-compiler-specific admonition">
<p class="first admonition-title">Compiler-specific</p>
<p class="last">This function is defined only on C++0x compilers</p>
</div>
<pre class="literal-block">
template &lt;typename... Args&gt;
std::pair &lt;iterator, bool&gt;  emplace_after (const_iterator after, Args&amp;&amp;... args);
</pre>
<p>Insert a <tt class="docutils literal">value_type</tt> object constructed with given arguments into the map unless the
map already contains one with equal key.  If the object is inserted, it will immediately
follow element pointed to by the given iterator in iteration order.  Iterators returned by
<tt class="docutils literal">before_begin()</tt> and <tt class="docutils literal">before_end()</tt> are commonly used for <tt class="docutils literal">after</tt>, but in addition
any valid iterator for the map is allowed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A pair of iterator pointing to inserted (or equal pre-existed) element and a
flag indicating whether insertion took place.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function, equality predicate or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.  Strong exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected constant (amortized); worst case linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
<div class="admonition-special-note admonition">
<p class="first admonition-title">Special note</p>
<p class="last">Purpose of similar functions in the standard <tt class="docutils literal">unordered_map</tt> is to avoid moving or
copying the constructed object.  Unfortunately, this is impossible to achieve with
closed hashing, so in <tt class="docutils literal">forward_hash_map</tt> this is not faster than simple
<tt class="docutils literal">insert()</tt>.  This function exists mostly for compatibility reasons.</p>
</div>
</div>
<div class="section" id="id273">
<h4><a class="toc-backref" href="#id718"><tt class="docutils literal">pop_front ()</tt></a></h4>
<pre class="literal-block">
void  pop_front ();
</pre>
<p>Erase the first element in the map’s iteration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">The map must not be empty.  Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id274">
<h4><a class="toc-backref" href="#id719"><tt class="docutils literal">erase_after (iterator)</tt></a></h4>
<pre class="literal-block">
void  erase_after (const_iterator position);
</pre>
<p>Erase the element <em>following</em> given <tt class="docutils literal">position</tt>.  Note that in forward hash tables it is
not possible to erase elements by having an iterator pointing to them: you need an
iterator pointing to the previous element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id275">
<h4><a class="toc-backref" href="#id720"><tt class="docutils literal">erase_after (position, last)</tt></a></h4>
<pre class="literal-block">
void  erase_after (const_iterator position, const_iterator last);
</pre>
<p>Erase a range of elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in distance between <tt class="docutils literal">position</tt> and <tt class="docutils literal">last</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id276">
<h4><a class="toc-backref" href="#id721"><tt class="docutils literal">clear ()</tt></a></h4>
<pre class="literal-block">
void  clear ();
</pre>
<p>Erase all elements in the map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Never throws.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in <tt class="docutils literal">bucket_count()</tt>.  Constant for empty maps.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id277">
<h4><a class="toc-backref" href="#id722"><tt class="docutils literal">swap (that)</tt></a></h4>
<pre class="literal-block">
void  swap (forward_hash_map&amp; that);
</pre>
<p>Swap contents (elements), hash function, equality predicates and maximum load factors
between two maps.  Allocators are not swapped.  Iteration orders are swapped along with
elements: after swapping, <tt class="docutils literal">this</tt> map will yield the same sequence of elements as
<tt class="docutils literal">that</tt> map did before, and vice versa.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Only if allocators are different: exceptions thrown by (either map’s) hash
function, equality predicates or allocator.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">If the allocators are equal the function never throws. Otherwise strong
exception safety.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if the allocators are equal.  Otherwise the same as copying the
two maps, see the copy constructor.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id278">
<h3><a class="toc-backref" href="#id723">Iteration Order Modifications</a></h3>
<p>Note that since container is a <em>map</em>, below operations don’t change its equality.
I.e. the container after the operation will always be equal (as defined by <tt class="docutils literal">operator==</tt>)
to itself before the operation.</p>
<p>These functions never invalidate iterators or throw anything.</p>
<div class="section" id="id279">
<h4><a class="toc-backref" href="#id724"><tt class="docutils literal">relink_after (to_after, from_after)</tt></a></h4>
<pre class="literal-block">
void  relink_after (const_iterator to_after, iterator from_after);
</pre>
<p>Relink the element immediately following the second argument iterator after the first
argument iterator.  Both arguments may be <tt class="docutils literal">before_begin()</tt> or some valid iterators,
except that <tt class="docutils literal">from_after</tt> must not be equal to <tt class="docutils literal">before_end()</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">It is allowed to pass equal iterators or try to relink an element after
itself; in both these cases nothing will be done.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id280">
<h4><a class="toc-backref" href="#id725"><tt class="docutils literal">reverse ()</tt></a></h4>
<pre class="literal-block">
void  reverse ();
</pre>
<p>Reverse the order in which container’s elements are iterated.  I.e. formerly first element
becomes the last, second element becomes second to last and so on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Linear in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id281">
<h4><a class="toc-backref" href="#id726"><tt class="docutils literal">sort ([compare])</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.6</p>
</div>
<pre class="literal-block">
void  sort ();

template &lt;typename Compare&gt;
void  sort (Compare compare);
</pre>
<p>Reorder map elements so that they are iterated in ascending order.  In the first version
elements are compared using <tt class="docutils literal">operator&lt;</tt> on their keys, in the second case — with the
<tt class="docutils literal">compare</tt> function object.  Sorting is guaranteed to be stable.  Comparison doesn’t have
to be consistent with map’s equality predicate; in particular, <tt class="docutils literal">compare</tt> may completely
ignore key part and compare the “mapped” part of elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the used comparison function.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Basic exception safety: if an exception is thrown, order of elements is
undefined.  Does not invalidate iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">O(<tt class="docutils literal">n log n</tt>) where <tt class="docutils literal">n</tt> is the map size.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id282">
<h3><a class="toc-backref" href="#id727">Hashing Policy</a></h3>
<div class="section" id="id283">
<h4><a class="toc-backref" href="#id728"><tt class="docutils literal">load_factor ()</tt></a></h4>
<pre class="literal-block">
float  load_factor ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Current load factor of the container.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id284">
<h4><a class="toc-backref" href="#id729"><tt class="docutils literal">max_load_factor ()</tt></a></h4>
<pre class="literal-block">
float  max_load_factor ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Maximum allowed load factor of the container.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id285">
<h4><a class="toc-backref" href="#id730"><tt class="docutils literal">max_load_factor (set_to)</tt></a></h4>
<pre class="literal-block">
void  max_load_factor (float set_to);
</pre>
<p>Change maximum load factor of the map.  If the new maximum is smaller than the current
load factor, the map is rehashed to reduce the load.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators if a rehash is trigerred.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if <tt class="docutils literal"><span class="pre">load_factor()&nbsp;&lt;&nbsp;set_to</span></tt>; otherwise same as for <tt class="docutils literal">rehash()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id286">
<h4><a class="toc-backref" href="#id731"><tt class="docutils literal">rehash (num_buckets)</tt></a></h4>
<pre class="literal-block">
void  rehash (size_type num_buckets);
</pre>
<p>Change bucket count to given value, if possible.  Implementation can alter <tt class="docutils literal">num_buckets</tt>
as needed to have load factor small enough as well as for internal reasons.  In
particular, it is legal to specify zero as number of buckets: this will be replaced with
the smallest number that keeps load below the allowed maximum.  Finally, it sometimes
makes sense (for performance) to rehash to the same number of buckets as before to “clean”
the container after erasing elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">bucket_count()</tt>; worst case quadratic in <tt class="docutils literal">size()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id287">
<h4><a class="toc-backref" href="#id732"><tt class="docutils literal">reserve (num_elements)</tt></a></h4>
<pre class="literal-block">
void  reserve (size_type num_elements);
</pre>
<p>Rehash the table in such a way that it will not be rehashed anymore if size doesn’t exceed
given value and no <tt class="docutils literal">erase()</tt>-like functions are used.  This is exactly identical to:</p>
<pre class="literal-block">
map.rehash (std::ceil (num_elements / map.max_load_factor ()));
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Invalidates iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Same as for <tt class="docutils literal">rehash()</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id288">
<h3><a class="toc-backref" href="#id733">Construction Parameter Queries</a></h3>
<div class="section" id="id289">
<h4><a class="toc-backref" href="#id734"><tt class="docutils literal">hash_function ()</tt></a></h4>
<pre class="literal-block">
hasher  hash_function ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Map’s hash function object.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id290">
<h4><a class="toc-backref" href="#id735"><tt class="docutils literal">key_eq ()</tt></a></h4>
<pre class="literal-block">
key_equal  key_eq ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Map’s equality predicate object.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id291">
<h4><a class="toc-backref" href="#id736"><tt class="docutils literal">get_allocator ()</tt></a></h4>
<pre class="literal-block">
allocator_type  get_allocator ()  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Map’s allocator.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id292">
<h3><a class="toc-backref" href="#id737">Non-Member Functions</a></h3>
<div class="section" id="id293">
<h4><a class="toc-backref" href="#id738"><tt class="docutils literal">operator== (map1, map2)</tt></a></h4>
<pre class="literal-block">
operator== (const forward_hash_map &lt;...&gt;&amp; map1, const forward_hash_map &lt;...&gt;&amp; map2);
</pre>
<p>Compare the elements of the two maps.  Second element components (<tt class="docutils literal">mapped_type</tt>) are
compared with <tt class="docutils literal">operator==</tt>, while the first (<tt class="docutils literal">key_type</tt>) — with the map equality
predicate.  Remember that despite being (singly) linked, containers are still <em>maps</em>,
i.e. iteration order is irrelevant to container equality.</p>
<p>See also more generic <tt class="docutils literal">operator==</tt> in <a class="reference internal" href="#cross-container-functions">Cross-Container Functions</a> section.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the maps are equal, i.e. contain the same elements.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Result does <em>not</em> depend on either maps’ iteration order.  It is undefined
if the maps’ equality predicates are not equivalent.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Expected linear in <tt class="docutils literal">size()</tt>; worst case is quadratic in <tt class="docutils literal">size()</tt>.
Optimizations: constant for comparing a map with itself or comparing maps of
different sizes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id294">
<h4><a class="toc-backref" href="#id739"><tt class="docutils literal">operator!= (map1, map2)</tt></a></h4>
<pre class="literal-block">
operator!= (const forward_hash_map &lt;...&gt;&amp; map1, const forward_hash_map &lt;...&gt;&amp; map2);
</pre>
<p>See <tt class="docutils literal">operator==</tt> for details.</p>
</div>
<div class="section" id="id295">
<h4><a class="toc-backref" href="#id740"><tt class="docutils literal">swap (map1, map2)</tt></a></h4>
<pre class="literal-block">
void  swap (forward_hash_map &lt;...&gt;&amp; map1, forward_hash_map &lt;...&gt;&amp; map2);
</pre>
<p>Effect is identical to <tt class="docutils literal">map1.swap (map2)</tt>.  See the function for details.</p>
</div>
<div class="section" id="id296">
<h4><a class="toc-backref" href="#id741"><tt class="docutils literal"><span class="pre">boost::serialization::serialize</span> (archive, map, version)</tt></a></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.6</p>
</div>
<p>A function defined in a separate header <tt class="docutils literal"><span class="pre">&lt;mct/hash-map-serialization.hpp&gt;</span></tt>.  Allows to
serialize and unserialize forward hash maps using common Boost.Serialization mechanisms.</p>
</div>
</div>
</div>
<div class="section" id="huge-linked-hash-and-huge-forward-hash">
<span id="huge-forward-hash-tables"></span><span id="huge-linked-hash-tables"></span><h2><a class="toc-backref" href="#id342"><tt class="docutils literal">huge_linked_hash_*</tt> and <tt class="docutils literal">huge_forward_hash_*</tt></a></h2>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.4</p>
</div>
<p>In addition to the normal linked and forward sets and maps, there are also “huge”
variants.  These are completely interface-identical to the “non-huge” version and are
therefore not documented in details; simply see the reference section for the
corresponding normal container.</p>
<p>The only difference between normal and “huge” containers is that the number of buckets in
the former is capped at roughly 1 billion <a class="footnote-reference" href="#id298" id="id297">[4]</a> on most platforms, while in “huge” ones it
is limited only by available memory.  However, on many platforms, most notably widespread
x86-64, normal containers use considerably less memory.</p>
<p>Since bucket count limit is extremely unlikely to be a concern and because of the memory
footprint advantage, it was decided to provide the somewhat limited containers as the
default.</p>
<p>It is also worth noting that on platforms where pointer size doesn’t exceed size of
<tt class="docutils literal">int</tt>, for example on x86-32, normal and “huge” containers will be <em>exactly</em> the same,
though still different classes.</p>
<table class="docutils footnote" frame="void" id="id298" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id297">[4]</a></td><td>Precisely <tt class="docutils literal"><span class="pre">(std::numeric_limits&nbsp;&lt;int&gt;::max&nbsp;()&nbsp;+&nbsp;1)&nbsp;/&nbsp;2</span></tt>, which is e.g.
1,073,741,824 on x86-64 machines.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="cross-container-functions">
<h2><a class="toc-backref" href="#id343">Cross-Container Functions</a></h2>
<p>It is possible to compare containers of certain distinct types.</p>
<div class="section" id="hash-table-containers">
<h3>Hash Table Containers</h3>
<div class="section" id="operator-table1-table2">
<h4><tt class="docutils literal">operator== (table1, table2)</tt></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.4</p>
</div>
<pre class="literal-block">
operator== (const hash_table_type_1&amp; table1, const hash_table_type_2&amp; table2);
</pre>
<p>Compare the elements of the two <em>compatible</em> containers.  Two containers are compatible
when all of the following are true:</p>
<ul class="simple">
<li>either both are sets or both are maps;</li>
<li>containers have the same <tt class="docutils literal">value_type</tt>;</li>
<li>containers have the same equality predicate type;</li>
<li>the two equality predicates are equivalent (unlike the previous items, this cannot be
checked by the compiler).</li>
</ul>
<p>To put it differently, containers or their types can differ in:</p>
<ul class="simple">
<li>the principle type (<tt class="docutils literal">closed_hash_*</tt>, <tt class="docutils literal">linked_hash_*</tt> and so on);</li>
<li>hash function objects and/or types;</li>
<li>allocator objects and/or types.</li>
</ul>
<p>As an example, you can compare <tt class="docutils literal"><span class="pre">closed_hash_set&nbsp;&lt;int&gt;</span></tt> with <tt class="docutils literal"><span class="pre">forward_hash_set&nbsp;&lt;int&gt;</span></tt>,
but not <tt class="docutils literal"><span class="pre">linked_hash_map&nbsp;&lt;int,&nbsp;bool&gt;</span></tt> with <tt class="docutils literal"><span class="pre">linked_hash_map&nbsp;&lt;int,&nbsp;long&gt;</span></tt>.</p>
<p>For maps the second element components (<tt class="docutils literal">mapped_type</tt>) are compared with <tt class="docutils literal">operator==</tt>,
while the first (<tt class="docutils literal">key_type</tt>) — with the map equality predicate.  Iteration order of
either container does not influence comparison result, even for linked containers.
I.e. MCT hash tables are <em>sets</em> and <em>maps</em>, which are essentially unordered concepts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the containers are equal, i.e. contain the same elements.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by hash function or equality predicate of either
container.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">Result does <em>not</em> depend on either containers’ iteration order.  It is
undefined if the containers’ equality predicates are not equivalent.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">If both tables are closed: expected O(<tt class="docutils literal">bucket_count()</tt>); worst case
O(<tt class="docutils literal"><span class="pre">bucket_count()&nbsp;*&nbsp;size()</span></tt>).  If at least one table is linked or forward:
expected linear in <tt class="docutils literal">size()</tt>; worst case is quadratic in <tt class="docutils literal">size()</tt>.
Optimizations: constant for comparing a table with itself or comparing
tables of different sizes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id299">
<h4><tt class="docutils literal">operator!= (table1, table2)</tt></h4>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.4</p>
</div>
<pre class="literal-block">
operator!= (const hash_table_type_1&amp; table1, const hash_table_type_2&amp; table2);
</pre>
<p>See <tt class="docutils literal">operator==</tt> for details.</p>
</div>
</div>
</div>
<div class="section" id="common-debugging-members">
<h2><a class="toc-backref" href="#id344">Common Debugging Members</a></h2>
<p>These member types and functions are defined only if any of <tt class="docutils literal">MCT_ENABLE_DEBUGGING</tt>,
<tt class="docutils literal">MCT_CHECK_PRECONDITIONS</tt> or <tt class="docutils literal">MCT_SELF_VALIDATION</tt> is defined and non-zero prior to
including any MCT headers.  Whether they are defined can be tested with
<tt class="docutils literal">MCT_DEBUGGING_MEMBERS</tt>.  The members are valid for all container classes in the
library.</p>
<p>Remember that <tt class="docutils literal">MCT_ENABLE_DEBUGGING</tt> only causes these members to be defined; they won’t
be called automatically.  If you need the latter refer to <a class="reference internal" href="#automated-debugging">Automated Debugging</a> section.</p>
<div class="contents local topic" id="id300">
<ul class="simple">
<li><a class="reference internal" href="#types" id="id742">Types</a><ul>
<li><a class="reference internal" href="#struct-statistics" id="id743"><tt class="docutils literal">struct statistics</tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#functions" id="id744">Functions</a><ul>
<li><a class="reference internal" href="#valid-iterator-position" id="id745"><tt class="docutils literal">valid_iterator (position)</tt></a></li>
<li><a class="reference internal" href="#valid-iterator-range-first-last" id="id746"><tt class="docutils literal">valid_iterator_range (first, last)</tt></a></li>
<li><a class="reference internal" href="#used-memory" id="id747"><tt class="docutils literal">used_memory ()</tt></a></li>
<li><a class="reference internal" href="#validate-integrity" id="id748"><tt class="docutils literal">validate_integrity ()</tt></a></li>
<li><a class="reference internal" href="#collect-statistics" id="id749"><tt class="docutils literal">collect_statistics ()</tt></a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="types">
<h3><a class="toc-backref" href="#id742">Types</a></h3>
<div class="section" id="struct-statistics">
<h4><a class="toc-backref" href="#id743"><tt class="docutils literal">struct statistics</tt></a></h4>
<p>A simple structure without any member functions and the following fields:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal">double&nbsp; debris_ratio</tt></dt>
<dd>Ratio of number of debris buckets to total number of occupied buckets.  See
implementation description for details.</dd>
<dt><tt class="docutils literal">double&nbsp; avg_present_lookup</tt></dt>
<dd>Average cost of looking up an element contained in the container.  Values
considerably higher than 1.0 indicate frequent hash collisions and possibly bad
choice of hash function.</dd>
<dt><tt class="docutils literal">size_type&nbsp; max_present_lookup</tt></dt>
<dd>Maximum cost of looking up a contained element.</dd>
<dt><tt class="docutils literal">double&nbsp; avg_absent_lookup</tt></dt>
<dd>Average cost of looking up an element not contained in the container.  This
assumes uniform hash distribution.  Usually strongly correlates with ratio of
number of occupied buckets to total number of buckets, but bad hash function can
increase this further.</dd>
<dt><tt class="docutils literal">size_type&nbsp; max_absent_lookup</tt></dt>
<dd>Maximum cost of looking up a non-contained element.</dd>
</dl>
</blockquote>
</div>
</div>
<div class="section" id="functions">
<h3><a class="toc-backref" href="#id744">Functions</a></h3>
<div class="section" id="valid-iterator-position">
<h4><a class="toc-backref" href="#id745"><tt class="docutils literal">valid_iterator (position)</tt></a></h4>
<pre class="literal-block">
bool  valid_iterator (const_iterator position)  const;
</pre>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if the iterator is valid for this container; past-the-end iterator
is <em>not</em> considered valid.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">For optimization reasons, a valid and an invalid iterator can be deemed
equal.  This function is more robust and much faster than comparing to all
valid iterators.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="valid-iterator-range-first-last">
<h4><a class="toc-backref" href="#id746"><tt class="docutils literal">valid_iterator_range (first, last)</tt></a></h4>
<pre class="literal-block">
bool  valid_iterator_range (const_iterator first, const_iterator last)  const;
</pre>
<p>For a range to be valid, both its ends must be valid or past-the-end iterators and
<tt class="docutils literal">first</tt> must precede or be equal to <tt class="docutils literal">last</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal">true</tt> if <tt class="docutils literal">[first, last)</tt> is a valid iterator range.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant if either <tt class="docutils literal">first</tt> or <tt class="docutils literal">last</tt> is invalid and not past-the-end;
otherwise linear in distance between <tt class="docutils literal">first</tt> and <tt class="docutils literal">last</tt> or, for invalid
ranges, <tt class="docutils literal">first</tt> and <tt class="docutils literal">end()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="used-memory">
<h4><a class="toc-backref" href="#id747"><tt class="docutils literal">used_memory ()</tt></a></h4>
<pre class="literal-block">
size_type  used_memory ()  const;
</pre>
<p>Compute the total amount of memory used by the container.  This includes both the size of
the container structure (i.e. what you’d get by using <tt class="docutils literal">sizeof()</tt>) and the size of
dynamically allocated memory used to store the buckets.  If the container is empty and
doesn’t have an allocated bucket array, returned value is equal to the size of the
container structure even though <tt class="docutils literal">bucket_count()</tt> returns a non-zero value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Total amount of memory, in bytes.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body">Constant.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="validate-integrity">
<h4><a class="toc-backref" href="#id748"><tt class="docutils literal">validate_integrity ()</tt></a></h4>
<pre class="literal-block">
void  validate_integrity ()  const;
</pre>
<p>Perform internal structure validation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">An unspecified subclass of <tt class="docutils literal"><span class="pre">std::logic_error</span></tt> if any errors are detected.
Additionally, exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body"><em>At least</em> linear in <tt class="docutils literal">bucket_count()</tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="collect-statistics">
<h4><a class="toc-backref" href="#id749"><tt class="docutils literal">collect_statistics ()</tt></a></h4>
<pre class="literal-block">
statistics  collect_statistics ()  const;
</pre>
<p>Collect various information about current use and potential performance of the container.
Useful to determine why a container underperforms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Statistics reflecting current container composure and performance.</td>
</tr>
<tr class="field"><th class="field-name">Throws:</th><td class="field-body">Exceptions thrown by the hash function or equality predicate.</td>
</tr>
<tr class="field"><th class="field-name">Notes:</th><td class="field-body">These statistics don’t represent any past state of the container.</td>
</tr>
<tr class="field"><th class="field-name">Complexity:</th><td class="field-body"><em>At least</em> linear in <tt class="docutils literal">bucket_count()</tt>.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="type-properties">
<h2><a class="toc-backref" href="#id345">Type Properties</a></h2>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.6</p>
</div>
<p>MCT provides a few type properties to help with metaprogramming that involves library
containers.  Using these structures it is impossible to distinguish normal and “huge”
containers (for linked and forward tables), but since the types have no important
differences, that must not be a problem.</p>
<div class="contents local topic" id="id301">
<ul class="simple">
<li><a class="reference internal" href="#is-set" id="id750"><tt class="docutils literal">is_set</tt></a></li>
<li><a class="reference internal" href="#is-map" id="id751"><tt class="docutils literal">is_map</tt></a></li>
<li><a class="reference internal" href="#is-closed-is-linked-and-is-forward" id="id752"><tt class="docutils literal">is_closed</tt>, <tt class="docutils literal">is_linked</tt> and <tt class="docutils literal">is_forward</tt></a></li>
</ul>
</div>
<div class="section" id="is-set">
<h3><a class="toc-backref" href="#id750"><tt class="docutils literal">is_set</tt></a></h3>
<p>The class is defined in header <tt class="docutils literal"><span class="pre">&lt;mct/hash-set.hpp&gt;</span></tt>.  Determines if <tt class="docutils literal">type</tt> is an MCT
set container.  E.g.:</p>
<pre class="literal-block">
is_set &lt;closed_hash_set &lt;int&gt; &gt;::value == true
</pre>
<p>Note, however, that it works only for MCT containers.  For example:</p>
<pre class="literal-block">
is_set &lt;std::set &lt;int&gt; &gt;::value == false
</pre>
</div>
<div class="section" id="is-map">
<h3><a class="toc-backref" href="#id751"><tt class="docutils literal">is_map</tt></a></h3>
<p>The class is defined in header <tt class="docutils literal"><span class="pre">&lt;mct/hash-map.hpp&gt;</span></tt>.  Determines if <tt class="docutils literal">type</tt> is an MCT
map container.  E.g.:</p>
<pre class="literal-block">
is_map &lt;linked_hash_map &lt;int, long&gt; &gt;::value == true
</pre>
<p>Note, however, that it works only for MCT containers.  For example:</p>
<pre class="literal-block">
is_map &lt;std::map &lt;int, long&gt; &gt;::value == false
</pre>
</div>
<div class="section" id="is-closed-is-linked-and-is-forward">
<h3><a class="toc-backref" href="#id752"><tt class="docutils literal">is_closed</tt>, <tt class="docutils literal">is_linked</tt> and <tt class="docutils literal">is_forward</tt></a></h3>
<p>These are defined if either <tt class="docutils literal"><span class="pre">&lt;mct/hash-set.hpp&gt;</span></tt> or <tt class="docutils literal"><span class="pre">&lt;mct/hash-map.hpp&gt;</span></tt> is included.
Determine if <tt class="docutils literal">type</tt> is an MCT closed, linked or forward hash table (either a set or a
map) correspondingly.  For instance:</p>
<pre class="literal-block">
is_closed  &lt;forward_hash_set &lt;short&gt; &gt;::value == false
is_linked  &lt;forward_hash_set &lt;short&gt; &gt;::value == false
is_forward &lt;forward_hash_set &lt;short&gt; &gt;::value == true
</pre>
</div>
</div>
<div class="section" id="external-use-specification">
<h2><a class="toc-backref" href="#id346">External Use Specification</a></h2>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.2</p>
</div>
<p>MCT provides a generic mechanism for specifying information about external use of types.
This is done by specializing <tt class="docutils literal">external_use</tt> structure in <tt class="docutils literal">mct</tt> namespace.  Other
structures described in this section can be seen as auxiliary.</p>
<p>All structures are defined in header <tt class="docutils literal">&lt;mct/intrusiveness.hpp&gt;</tt>.  However, including
either of <tt class="docutils literal"><span class="pre">&lt;mct/hash-set.hpp&gt;</span></tt> or <tt class="docutils literal"><span class="pre">&lt;mct/hash-map.hpp&gt;</span></tt> is guaranteed to define them as
well.</p>
<div class="contents local topic" id="id302">
<ul class="simple">
<li><a class="reference internal" href="#external-use" id="id753"><tt class="docutils literal">external_use</tt></a><ul>
<li><a class="reference internal" href="#id303" id="id754">Definition</a></li>
<li><a class="reference internal" href="#predefined-specializations" id="id755">Predefined Specializations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#supports-external-use" id="id756"><tt class="docutils literal">supports_external_use</tt></a></li>
<li><a class="reference internal" href="#extern-use-field" id="id757"><tt class="docutils literal">extern_use_field</tt></a><ul>
<li><a class="reference internal" href="#id304" id="id758">Definition</a></li>
<li><a class="reference internal" href="#usage-examples" id="id759">Usage Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#intrusive-storage" id="id760"><tt class="docutils literal">intrusive_storage</tt></a><ul>
<li><a class="reference internal" href="#id305" id="id761">Definition</a></li>
<li><a class="reference internal" href="#id306" id="id762">Type Members</a></li>
</ul>
</li>
<li><a class="reference internal" href="#propagate-external-use" id="id763"><tt class="docutils literal">propagate_external_use</tt></a></li>
</ul>
</div>
<div class="section" id="external-use">
<h3><a class="toc-backref" href="#id753"><tt class="docutils literal">external_use</tt></a></h3>
<p>Templated structure that specifies external use information for a type.  By default it is
empty and is intended to be specialized by users of MCT.</p>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">Exact contents of specializations is not fixed yet and might change in later versions.
The <em>only</em> correct way to specialize is to inherit from <tt class="docutils literal">extern_use_field</tt>
currently.  See examples below, in the sections describing the mentioned structure.</p>
</div>
<p>Because of currently undefined contents, this structure is of little use (other than
specializing) outside MCT.  Inside the library, <tt class="docutils literal">closed_hash_set</tt> and
<tt class="docutils literal">closed_hash_map</tt> can leverage external use information to provide better performance.</p>
<div class="section" id="id303">
<h4><a class="toc-backref" href="#id754">Definition</a></h4>
<pre class="literal-block">
template &lt;typename Type,
          typename Enable = void&gt;
struct external_use;
</pre>
<p>Template parameters:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">Type</tt>:</th><td class="field-body">The type to which external use information applies</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Enable</tt>:</th><td class="field-body">“Hidden” template parameter, for the purpose of using constructs like
<tt class="docutils literal"><span class="pre">std::enable_if</span></tt> or <tt class="docutils literal"><span class="pre">boost::enable_if</span></tt></td>
</tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="predefined-specializations">
<h4><a class="toc-backref" href="#id755">Predefined Specializations</a></h4>
<p>The structure is already specialized for <tt class="docutils literal"><span class="pre">std::pair&nbsp;&lt;First,&nbsp;Second&gt;</span></tt> where
<tt class="docutils literal">supports_external_use</tt> is <tt class="docutils literal">true</tt> for <tt class="docutils literal">First</tt> or <tt class="docutils literal">Second</tt> or both.  In other
words, if you provide external use information for <tt class="docutils literal">MyType</tt>, such information will also
apply for <tt class="docutils literal"><span class="pre">std::pair&nbsp;&lt;MyType,&nbsp;*&gt;</span></tt> and <tt class="docutils literal"><span class="pre">std::pair&nbsp;&lt;*,&nbsp;MyType&gt;</span></tt>.  And, recursively, to
<tt class="docutils literal"><span class="pre">std::pair&nbsp;&lt;std::pair&nbsp;&lt;MyType,&nbsp;*&gt;,&nbsp;*&gt;</span></tt> and so forth.</p>
<p>There are no specializations for concrete types.</p>
</div>
</div>
<div class="section" id="supports-external-use">
<h3><a class="toc-backref" href="#id756"><tt class="docutils literal">supports_external_use</tt></a></h3>
<p>Type property structure, simply determining whether <tt class="docutils literal">external_use</tt> for a type is
properly specialized.  The only member is variable <tt class="docutils literal">value</tt> of type <tt class="docutils literal">bool</tt>.  E.g.:</p>
<blockquote>
supports_external_use &lt;int&gt;::value == false</blockquote>
</div>
<div class="section" id="extern-use-field">
<h3><a class="toc-backref" href="#id757"><tt class="docutils literal">extern_use_field</tt></a></h3>
<p>A type that can be (and currently should be, see warning above) used as a base class when
specializing <tt class="docutils literal">external_use</tt>.</p>
<div class="section" id="id304">
<h4><a class="toc-backref" href="#id758">Definition</a></h4>
<pre class="literal-block">
template &lt;typename Type,
          typename Value,
          Value Type::* field&gt;
struct extern_use_field;
</pre>
<p>Template parameters:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">Type</tt>:</th><td class="field-body">The type which contains a field dedicated for external use</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">Value</tt>:</th><td class="field-body">The type of the field; must be either of an integral type other than <tt class="docutils literal">bool</tt> or
support external use in turn</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">field</tt>:</th><td class="field-body">Pointer-to-member for the field dedicated for external use</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="usage-examples">
<h4><a class="toc-backref" href="#id759">Usage Examples</a></h4>
<p>This assumes that <tt class="docutils literal">MyClass</tt> has a public field named <tt class="docutils literal">_unused_field</tt> of type <tt class="docutils literal">char</tt>,
which it will not use itself and dedicates for external use:</p>
<pre class="literal-block">
namespace mct
{
  template &lt;&gt;
  struct external_use &lt;MyClass&gt;
    : extern_use_field &lt;MyClass, char, &amp;MyClass::_unused_field&gt;
  { };
}
</pre>
<p>Note that “will not use itself” precondition includes assignment operator too.  In the
example above, <tt class="docutils literal">MyClass</tt> must have an explicitly defined assignment operator as one
implicitly generated by compiler would alter <tt class="docutils literal">_unused_field</tt>.</p>
<p>Now, suppose <tt class="docutils literal">MyCompositeClass</tt> has a public field named <tt class="docutils literal">a_field</tt> of type
<tt class="docutils literal">MyClass</tt>.  We can reuse external use information already registered for <tt class="docutils literal">MyClass</tt>
like this:</p>
<pre class="literal-block">
namespace mct
{
  template &lt;&gt;
  struct external_use &lt;MyCompositeClass&gt;
    : extern_use_field &lt;MyCompositeClass, MyClass, &amp;MyCompositeClass::a_field&gt;
  { };
}
</pre>
</div>
</div>
<div class="section" id="intrusive-storage">
<h3><a class="toc-backref" href="#id760"><tt class="docutils literal">intrusive_storage</tt></a></h3>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.4</p>
</div>
<p>A type-trait-like template that can be used to lookup a storage type for given <tt class="docutils literal">Value</tt>
when external use is desired.  It is not meant to be specialized.</p>
<p>For any <tt class="docutils literal">Value</tt> it is guaranteed that <tt class="docutils literal"><span class="pre">intrusive_storage&nbsp;&lt;Value&gt;::type</span></tt>:</p>
<ul class="simple">
<li>is either <tt class="docutils literal">Value</tt> or a subclass of <tt class="docutils literal">Value</tt>;</li>
<li>has the same size as <tt class="docutils literal">Value</tt>.</li>
</ul>
<p>Additionally, it may provide external use specification when <tt class="docutils literal">Value</tt> does not — that’s
the whole purpose of the template.  For instance, this is the case for
<tt class="docutils literal"><span class="pre">std::pair&nbsp;&lt;int,&nbsp;char&gt;</span></tt> at least on modern platforms.  Currently this is used by
<tt class="docutils literal">closed_hash_*</tt> containers to switch to a more efficient implementation when possible.</p>
<p>In a sense this template serves the same purpose as specializing <tt class="docutils literal">external_use</tt>, but
works mostly with types you have no control over, e.g. those in <tt class="docutils literal">std</tt> namespace.  It
also works automatically, without need to code anything.</p>
<div class="section" id="id305">
<h4><a class="toc-backref" href="#id761">Definition</a></h4>
<pre class="literal-block">
template &lt;typename Value&gt;
struct intrusive_storage;
</pre>
<p>Template parameters:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">Value</tt>:</th><td class="field-body">The type for which storage is requested; must be default-constructible</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="id306">
<h4><a class="toc-backref" href="#id762">Type Members</a></h4>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">type</tt>:</th><td class="field-body">Recommended storage type for the <tt class="docutils literal">Value</tt> type; see description above for
guarantees and purpose</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="section" id="propagate-external-use">
<h3><a class="toc-backref" href="#id763"><tt class="docutils literal">propagate_external_use</tt></a></h3>
<div class="admonition-deprecated admonition">
<p class="first admonition-title">Deprecated</p>
<div class="admonition-deprecation-description admonition">
<p class="first admonition-title">Deprecation description</p>
<p class="last">Deprecated since 1.4.  Use improved <tt class="docutils literal">extern_use_field</tt> instead.</p>
</div>
<pre class="literal-block">
template &lt;typename To,
          typename From,
          From To::* field&gt;
struct propagate_external_use;
</pre>
<p>Deriving an <tt class="docutils literal">external_use</tt> specialization from:</p>
<pre class="literal-block">
propagate_external_use &lt;A, B, &amp;A::x&gt;
</pre>
<p>gives exactly the same result as from:</p>
<pre class="literal-block">
extern_use_field &lt;A, B, &amp;A::x&gt;
</pre>
<p class="last">The structure was meaningful in 1.2, but since 1.4 <tt class="docutils literal">extern_use_field</tt> covers its
intended purpose too.</p>
</div>
</div>
</div>
<div class="section" id="automated-debugging">
<h2><a class="toc-backref" href="#id347">Automated Debugging</a></h2>
<p>In addition to the general debugging functions described earlier, MCT provides tools for
automated debugging of problems.</p>
<div class="contents local topic" id="id307">
<ul class="simple">
<li><a class="reference internal" href="#id308" id="id764"><tt class="docutils literal">MCT_CHECK_PRECONDITIONS</tt></a></li>
<li><a class="reference internal" href="#id309" id="id765"><tt class="docutils literal">MCT_SELF_VALIDATION</tt></a></li>
</ul>
</div>
<div class="section" id="id308">
<h3><a class="toc-backref" href="#id764"><tt class="docutils literal">MCT_CHECK_PRECONDITIONS</tt></a></h3>
<p>MCT functions are capable of automatically checking their preconditions to some extent.
To activate this mode, define <tt class="docutils literal">MCT_CHECK_PRECONDITIONS</tt> to a non-zero value before
including any MCT header.  If a precondition test fails, function will throw
<tt class="docutils literal"><span class="pre">std::logic_error</span></tt> (or some unspecified subclass of that); this is not mentioned in
other reference sections.</p>
<p>This mode is a good way to detect many programming bugs like using an invalidated iterator
or popping from an empty <tt class="docutils literal">linked_hash_map</tt>.  However, don’t expect it to alert of all
possible problems.</p>
<p>Automatic precondition testing can be moderately slow, so consider that before enabling
the mode.  Additionally, later versions of MCT can add more precondition tests thus
increasing performance hit.</p>
<p>Setting <tt class="docutils literal">MCT_CHECK_PRECONDITIONS</tt> to a non-zero value causes definition of the <a class="reference internal" href="#common-debugging-members">common
debugging members</a>.</p>
</div>
<div class="section" id="id309">
<h3><a class="toc-backref" href="#id765"><tt class="docutils literal">MCT_SELF_VALIDATION</tt></a></h3>
<p>It is possible to force MCT into a self-validating mode by defining
<tt class="docutils literal">MCT_SELF_VALIDATION</tt> to a non-zero value.  This allows to spot bugs (usually caused by
memory corruption or invalid parameters supplied to container functions) quickly.
However, this leads to <strong>extremely poor performance</strong>, and thus should be used only when
you suspect there is a problem.  (The kind of slowdown this causes can be assessed from
MCT’s own test suite as self-validation is part of the reason it takes time to pass.)</p>
<p>Setting <tt class="docutils literal">MCT_SELF_VALIDATION</tt> to a non-zero value causes definition of the <a class="reference internal" href="#common-debugging-members">common
debugging members</a>.</p>
</div>
</div>
<div class="section" id="preprocessor-symbols">
<h2><a class="toc-backref" href="#id348">Preprocessor Symbols</a></h2>
<p>This section lists some preprocessor symbols (macros) that are useful to clients of the
package.  There are some other symbols starting with prefix <tt class="docutils literal">MCT_</tt>, but they should be
considered private to the package and are not guaranteed to retain current meaning or even
stay in the package.</p>
<div class="contents local topic" id="id310">
<ul class="simple">
<li><a class="reference internal" href="#package-version" id="id766">Package Version</a></li>
<li><a class="reference internal" href="#configurable-dependencies" id="id767">Configurable Dependencies</a></li>
<li><a class="reference internal" href="#inclusion-time-configuration-derivatives" id="id768">Inclusion-Time Configuration Derivatives</a></li>
</ul>
</div>
<div class="section" id="package-version">
<h3><a class="toc-backref" href="#id766">Package Version</a></h3>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">MCT_MAJOR_VERSION</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">MCT_MINOR_VERSION</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">MCT_PATCH_VERSION</tt>:</th><td class="field-body">Three numbers of the package version.  MCT follows old Linux versioning scheme
where odd minor version means a development release.</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">MCT_VERSION_STRING</tt>:</th><td class="field-body">The version as a string, mainly if needed for presentation purposes.</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="configurable-dependencies">
<h3><a class="toc-backref" href="#id767">Configurable Dependencies</a></h3>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">MCT_HASH_HEADER</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">MCT_HASH_NAMESPACE</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">MCT_TYPE_TRAITS_HEADER</tt>:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">MCT_TYPE_TRAITS_NAMESPACE</tt>:</th><td class="field-body">Header and namespace for hash function and type traits definitions.  These symbols
either come from configuration determined at installation, or can be redefined at
inclusion time (see section <a class="reference internal" href="#inclusion-time-configuration">Inclusion-Time Configuration</a>).</td>
</tr>
<tr class="field"><th class="field-name"><tt class="docutils literal">MCT_HAVE_TYPE_TRAITS</tt>:</th><td class="field-body">Defined to non-zero if MCT uses type traits.</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="inclusion-time-configuration-derivatives">
<h3><a class="toc-backref" href="#id768">Inclusion-Time Configuration Derivatives</a></h3>
<p>Some symbols are defined by MCT itself based on configuration:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name"><tt class="docutils literal">MCT_DEBUGGING_MEMBERS</tt>:</th><td class="field-body">1 or 0 depending on whether containers provide <a class="reference internal" href="#common-debugging-members">common debugging members</a>.</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="section" id="full-list-of-headers">
<h2><a class="toc-backref" href="#id349">Full List of Headers</a></h2>
<p>This section lists all public header files in MCT along with types defined in them.  This
information is also available in other places of the reference, but this section
summarizes it.</p>
<div class="contents local topic" id="id311">
<ul class="simple">
<li><a class="reference internal" href="#hash-set-hpp" id="id769"><tt class="docutils literal"><span class="pre">hash-set.hpp</span></tt></a></li>
<li><a class="reference internal" href="#hash-map-hpp" id="id770"><tt class="docutils literal"><span class="pre">hash-map.hpp</span></tt></a></li>
<li><a class="reference internal" href="#intrusiveness-hpp" id="id771"><tt class="docutils literal">intrusiveness.hpp</tt></a></li>
<li><a class="reference internal" href="#hash-set-serialization-hpp" id="id772"><tt class="docutils literal"><span class="pre">hash-set-serialization.hpp</span></tt></a></li>
<li><a class="reference internal" href="#hash-map-serialization-hpp" id="id773"><tt class="docutils literal"><span class="pre">hash-map-serialization.hpp</span></tt></a></li>
<li><a class="reference internal" href="#config-hpp" id="id774"><tt class="docutils literal">config.hpp</tt></a></li>
</ul>
</div>
<div class="section" id="hash-set-hpp">
<h3><a class="toc-backref" href="#id769"><tt class="docutils literal"><span class="pre">hash-set.hpp</span></tt></a></h3>
<p>Defines several set hash table types along with associated type property:</p>
<ul class="simple">
<li><tt class="docutils literal">closed_hash_set</tt></li>
<li><tt class="docutils literal">linked_hash_set</tt></li>
<li><tt class="docutils literal">huge_linked_hash_set</tt></li>
<li><tt class="docutils literal">forward_hash_set</tt></li>
<li><tt class="docutils literal">huge_forward_hash_set</tt></li>
<li><tt class="docutils literal">is_set</tt></li>
</ul>
<p>Additionally defined type properties:</p>
<ul class="simple">
<li><tt class="docutils literal">is_closed</tt></li>
<li><tt class="docutils literal">is_linked</tt></li>
<li><tt class="docutils literal">is_forward</tt></li>
</ul>
<p>Finally, this header is guaranteed to also define all the types provided by
<tt class="docutils literal">intrusiveness.hpp</tt>.</p>
</div>
<div class="section" id="hash-map-hpp">
<h3><a class="toc-backref" href="#id770"><tt class="docutils literal"><span class="pre">hash-map.hpp</span></tt></a></h3>
<p>Defines several map hash table types along with associated type property:</p>
<ul class="simple">
<li><tt class="docutils literal">closed_hash_map</tt></li>
<li><tt class="docutils literal">linked_hash_map</tt></li>
<li><tt class="docutils literal">huge_linked_hash_map</tt></li>
<li><tt class="docutils literal">forward_hash_map</tt></li>
<li><tt class="docutils literal">huge_forward_hash_map</tt></li>
<li><tt class="docutils literal">is_map</tt></li>
</ul>
<p>Additionally defined type properties:</p>
<ul class="simple">
<li><tt class="docutils literal">is_closed</tt></li>
<li><tt class="docutils literal">is_linked</tt></li>
<li><tt class="docutils literal">is_forward</tt></li>
</ul>
<p>Finally, this header is guaranteed to also define all the types provided by
<tt class="docutils literal">intrusiveness.hpp</tt>.</p>
</div>
<div class="section" id="intrusiveness-hpp">
<h3><a class="toc-backref" href="#id771"><tt class="docutils literal">intrusiveness.hpp</tt></a></h3>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.2</p>
</div>
<p>Defines all the types used in external use specification:</p>
<ul class="simple">
<li><tt class="docutils literal">external_use</tt></li>
<li><tt class="docutils literal">supports_external_use</tt></li>
<li><tt class="docutils literal">extern_use_field</tt></li>
<li><tt class="docutils literal">intrusive_storage</tt></li>
<li><tt class="docutils literal">propagate_external_use</tt> (deprecated)</li>
</ul>
<p>This header is guaranteed to be included if either <tt class="docutils literal"><span class="pre">hash-set.hpp</span></tt> or <tt class="docutils literal"><span class="pre">hash-map.hpp</span></tt> or
their serialization variants is included.</p>
</div>
<div class="section" id="hash-set-serialization-hpp">
<h3><a class="toc-backref" href="#id772"><tt class="docutils literal"><span class="pre">hash-set-serialization.hpp</span></tt></a></h3>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.6</p>
</div>
<p>Doesn’t define any types, but overloads <tt class="docutils literal"><span class="pre">boost::serialization::serialize()</span></tt> for set hash
tables.  Including this header if Boost.Serialization is not installed will lead to
compilation errors.  The header includes <tt class="docutils literal"><span class="pre">hash-set.hpp</span></tt> itself, so there is no need to
include both.</p>
</div>
<div class="section" id="hash-map-serialization-hpp">
<h3><a class="toc-backref" href="#id773"><tt class="docutils literal"><span class="pre">hash-map-serialization.hpp</span></tt></a></h3>
<div class="admonition-versioned admonition">
<p class="first admonition-title">Versioned</p>
<p class="last">Since 1.6</p>
</div>
<p>Doesn’t define any types, but overloads <tt class="docutils literal"><span class="pre">boost::serialization::serialize()</span></tt> for map hash
tables.  Including this header if Boost.Serialization is not installed will lead to
compilation errors.  The header includes <tt class="docutils literal"><span class="pre">hash-map.hpp</span></tt> itself, so there is no need to
include both.</p>
</div>
<div class="section" id="config-hpp">
<h3><a class="toc-backref" href="#id774"><tt class="docutils literal">config.hpp</tt></a></h3>
<p>Semi-internal header defining all the symbols listed in <a class="reference internal" href="#preprocessor-symbols">Preprocessor Symbols</a> section.
Including any other MCT header is guaranteed to include <tt class="docutils literal">config.hpp</tt>.</p>
</div>
</div>
<div class="section" id="api-changes">
<h2><a class="toc-backref" href="#id350">API Changes</a></h2>
<p>This section concisely lists new functionality, backward-incompatible changes and
deprecations by stable version.</p>
<div class="contents local topic" id="id312">
<ul class="simple">
<li><a class="reference internal" href="#in-version-1-2" id="id775">In version 1.2</a></li>
<li><a class="reference internal" href="#in-version-1-4" id="id776">In version 1.4</a></li>
<li><a class="reference internal" href="#in-version-1-6" id="id777">In version 1.6</a></li>
</ul>
</div>
<div class="section" id="in-version-1-2">
<h3><a class="toc-backref" href="#id775">In version 1.2</a></h3>
<ul class="simple">
<li>New class templates:<ul>
<li><tt class="docutils literal">forward_hash_set</tt></li>
<li><tt class="docutils literal">forward_hash_map</tt></li>
<li><tt class="docutils literal">external_use</tt></li>
<li><tt class="docutils literal">supports_external_use</tt></li>
<li><tt class="docutils literal">extern_use_field</tt></li>
<li><tt class="docutils literal">propagate_external_use</tt></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="in-version-1-4">
<h3><a class="toc-backref" href="#id776">In version 1.4</a></h3>
<ul class="simple">
<li>New class templates:<ul>
<li><tt class="docutils literal">huge_linked_hash_set</tt></li>
<li><tt class="docutils literal">huge_linked_hash_map</tt></li>
<li><tt class="docutils literal">huge_forward_hash_set</tt></li>
<li><tt class="docutils literal">huge_forward_hash_map</tt></li>
<li><tt class="docutils literal">intrusive_storage</tt></li>
</ul>
</li>
<li>New member functions:<ul>
<li><tt class="docutils literal">quick_erase()</tt> in <tt class="docutils literal">closed_hash_*</tt> and <tt class="docutils literal">linked_hash_*</tt></li>
</ul>
</li>
<li>New free functions:<ul>
<li><tt class="docutils literal">operator==</tt> and <tt class="docutils literal">operator!=</tt> — cross-container</li>
</ul>
</li>
<li>Backward-incompatible:<ul>
<li><tt class="docutils literal">linked_hash_*</tt> and <tt class="docutils literal">forward_hash_*</tt> now have a smaller (but still <em>very</em> large)
bucket count limit on certain platforms</li>
</ul>
</li>
<li>Deprecated class templates:<ul>
<li><tt class="docutils literal">propagate_external_use</tt></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="in-version-1-6">
<h3><a class="toc-backref" href="#id777">In version 1.6</a></h3>
<ul class="simple">
<li>New class templates:<ul>
<li><tt class="docutils literal">is_set</tt></li>
<li><tt class="docutils literal">is_map</tt></li>
<li><tt class="docutils literal">is_closed</tt></li>
<li><tt class="docutils literal">is_linked</tt></li>
<li><tt class="docutils literal">is_forward</tt></li>
</ul>
</li>
<li>New member functions:<ul>
<li><tt class="docutils literal">sort()</tt> in <tt class="docutils literal">linked_hash_*</tt> and <tt class="docutils literal">forward_hash_*</tt></li>
</ul>
</li>
<li>New free functions:<ul>
<li><tt class="docutils literal"><span class="pre">boost::serialization::serialize</span></tt> for MCT containers — in separate headers
non-essential for the main functionality.</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="documentation-copyright-and-permissions-notice">
<h1><a class="toc-backref" href="#id351">Documentation Copyright and Permissions Notice</a></h1>
<p>Copyright © 2009, 2010, 2011, 2012 Paul Pogonyshev.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the “Software”), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.</p>
</div>
</div>
</body>
</html>
